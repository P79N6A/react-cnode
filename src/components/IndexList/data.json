{"success":true,"data":[{"id":"5bd4772a14e994202cd5bdb7","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>","title":"服务器迁移至 aws 日本机房","last_reply_at":"2019-04-02T05:42:38.585Z","good":false,"top":true,"reply_count":181,"visit_count":20225,"create_at":"2018-10-27T14:33:14.694Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5c73d9c2ab86b86ddf6b2b4a","author_id":"51f0f267f4963ade0e08f503","tab":"share","content":"<div class=\"markdown-text\"><p>更灵活的机动、更快的效率、更高的产能\nServerless - 解放的不仅仅是生产力，更是一种全新的思维方式。</p>\n<p>百姓网 Hax、上线了郭达峰、ThoughtWorks 陈欢、阿里云杜万、淘宝冰森等优秀分享者，\n期待与你一起进入嗨翻 server 的新场景。</p>\n<p><img src=\"//static.cnodejs.org/FlbUfz7IHVgS4DwmjSrXKiL9fMRl\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FlDAitTvYWpWsudI8VGjfjGGXYRr\" alt=\"image.png\"></p>\n<p>时间：03 月 16 日周六\n地点：上海证大五道口广场</p>\n<p>报名链接：<a href=\"https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2\">https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2</a>\n活动主页：<a href=\"https://taobaofed.github.io/nodejs-club/\">https://taobaofed.github.io/nodejs-club/</a></p>\n</div>","title":"Node 地下铁第八期「上海站」线下沙龙邀约 - Let's Go Serverless!","last_reply_at":"2019-03-21T01:39:18.715Z","good":false,"top":true,"reply_count":41,"visit_count":4879,"create_at":"2019-02-25T12:04:18.826Z","author":{"loginname":"lellansin","avatar_url":"https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"}},{"id":"5ca321436c1de62dce46703c","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>1. Dubbo 是啥？</h2>\n<p>Dubbo 是一个由阿里开源的 RPC 框架。</p>\n<p>简单说下RPC框架的背景。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6ly1g1his3o33yj20p40p011i.jpg\" alt=\"From dubbo.apache.org\"></p>\n<p>Dubbo 是一种 RPC 框架，应用在分布式服务。</p>\n<p><img src=\"http://dubbo.apache.org/img/architecture.png\" alt></p>\n<h2>2. 使用 Dubbo 实现 Java 互调</h2>\n<p>​\t首先我们可以先尝试下同语言下的 Dubbo 调用，从容易开始。</p>\n<p>​\t可以参考下 dubbo 官方文档 <a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>\n<p>​\t这边简单尝试下，主要有两步：</p>\n<ol>\n<li>\n<p>首先建立一个服务提供方， 也就是上图 Provider 的角色；</p>\n</li>\n<li>\n<p>接下来建立一个服务消费者， 也如同上图的 Consumer 的角色；</p>\n</li>\n</ol>\n<h3>服务提供方建立 Provider</h3>\n<p><strong>1.0 使用Spring Boot 建立一个Spring 微服务</strong> (可以参考)<a href=\"http://https://yuchenzhen.github.io/2018/08/24/SpringBoot-IDE-initial/\">https://yuchenzhen.github.io/2018/08/24/SpringBoot-IDE-initial/</a></p>\n<p>**1.1.  建立一个 Interface **</p>\n<pre class=\"prettyprint language-   java\"><code>&#x2F;&#x2F; TestProviderService.java\n\npackage com.dubbo.learn.dubbo;\n\npublic interface TestProviderService {\n    String Hello (String who);\n}\n</code></pre><p><strong>1.2 实现这个TestProviderServiceImpl</strong></p>\n<pre class=\"prettyprint language- java\"><code>&#x2F;&#x2F; TestProviderServiceImpl\npackage com.dubbo.learn.dubbo.impl;\n\nimport com.dubbo.learn.dubbo.TestProviderService;\nimport com.alibaba.dubbo.config.annotation.Service;\n\n@Service(version=&quot;1.0.0&quot;)\npublic class TestProviderServiceImpl implements TestProviderService  {\n    public String Hello(String who) {\n        return &quot;Hello world ! Dear Programer &quot; + who ;\n    }\n}\n\n</code></pre><p><strong>1.3 启动程序主入口添加<code>@EnableDubbo</code>注解</strong></p>\n<pre class=\"prettyprint language- java\"><code>&#x2F;&#x2F; ProviderApplication.java\npackage com.dubbo.learn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;\n\n@SpringBootApplication\n@EnableDubbo\npublic class ProviderApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderApplication.class, args);\n    }\n\n}\t\n</code></pre><p>​\t为了引入这个<code>@EnableDubbo</code>注解，需要我们引入<code>com.alibaba</code>的包</p>\n<pre class=\"prettyprint language-xml\"><code>&lt;!--pom.xml--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt; \n  &lt;version&gt;0.2.1.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n</code></pre><p>​\t<code>curator-framework</code>是dubbo所使用的消息中心<code>Zookeeper</code>所需要的包<br>\n​\t<code>dubbo-spring-boot-starter</code>是 dubbo spring 的配置包</p>\n<p><strong>1.4 最后我们把dubbo 的启动配置写到<code>application.properties</code>里面</strong></p>\n<pre class=\"prettyprint language-properties\"><code># application.properties\nserver.port = 8829\n#\ndubbo.application.name=provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=zookeeper:&#x2F;&#x2F;127.0.0.1:2181\ndubbo.scan.base-packages=com.dubboo.learn\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\ndubbo.consumer.check=false\n</code></pre><p>整个项目结构如图：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1ffq5j1mrj20a70jhab5.jpg\" alt></p>\n<p>然后，启动就好。</p>\n<p>启动之后，通过 dubbo Admin 网页客户端可以看见Provider的接口在 Regitry 里面注册成功。<br>\n<img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1ffrs83ubj227m0n8djl.jpg\" alt></p>\n<h3>服务消费者Consumer</h3>\n<p><strong>1.0 使用Spring Boot 建立一个Spring 消费者的微服务</strong></p>\n<p><strong>1.1 定义接口，这里的接口路径位置和包名最好一致 （不然要自己调整）</strong></p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; TestProviderService.java\npackage com.dubbo.learn.dubbo;\npublic interface TestProviderService {\n    String Hello (String who);\n}\n</code></pre><p><strong>1.2 定义一个 Service调用该dubbo 接口</strong></p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; TestConsumerService.java\npackage com.dubbo.learn;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.dubbo.learn.dubbo.TestProviderService;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class TestConsumerService {\n    @Reference(version = &quot;1.0.0&quot;)\n    TestProviderService testProviderService;\n\n    public void consumer (String who) {\n        String res = testProviderService.Hello(who);\n        System.out.println(&quot;consumer : provider says &quot; + res);\n    }\n}\n</code></pre><p>在主程序函数调用该Service 的函数</p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; DubboConsumerApplication.java\npackage com.dubbo.learn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport com.dubbo.learn.TestConsumerService;\n\n@SpringBootApplication\npublic class DubboConsumerApplication {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(DubboConsumerApplication.class, args);\n        TestConsumerService testConsumer = run.getBean(TestConsumerService.class);\n        testConsumer.consumer(&quot;White&quot;);\n    }\n\n}\n</code></pre><p><code>@Reference</code>这个注解就是用来调用 dubbo 对应的接口的。所以也是要引入跟服务端的那几个包</p>\n<pre class=\"prettyprint language-xml\"><code>&lt;!--pom.xml--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt; \n  &lt;version&gt;0.2.1.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;  \n</code></pre><p><strong>1.3 最后我们把dubbo 的启动配置写到application.properties里面</strong></p>\n<pre class=\"prettyprint language- properties\"><code>#application.properties\nserver.port=8830\ndubbo.application.name=consumer\n#注册中心地址\ndubbo.registry.address=zookeeper:&#x2F;&#x2F;127.0.0.1:2181\n\ndubbo.scan.base-packages=com.dubboo.learn.dubbo\ndubbo.protocol.port=20880\n</code></pre><p>项目目录结构如下：\n<img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1fgt0ik3aj20aa0irdgx.jpg\" alt></p>\n<p>启动后效果如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1fgfyr094j211l0e60yc.jpg\" alt></p>\n<h2>3. Node.js 如何通过 Dubbo 调用 Java</h2>\n<p>Node 这边通过 dubbo调用 Java 的 provider 的接口，我们尝试调用了几个包：sofa-rpc-node，node-zookeeper-dubbo，和dubbo2.js 。<br>\n其中 sofa-rpc-node 的对使用 egg.js框架的比较友好，node-zookeeper-dubbo 使用起来跟 sofa-rpc-node 差不多；但是有点麻烦的就是这两个包都需要写 proto3的接口定义。<br>\n而 dubbo2.js则比较方便，以下是使用 dubbo2.js 的示列</p>\n<pre class=\"prettyprint language-javascript\"><code>const { Dubbo, java, setting } = require(&#x27;dubbo2.js&#x27;)\nconst interfaceName = &#x27;com.dubbo.learn.dubbo.TestProviderService&#x27;\nconst interfaceVersion = &#x27;1.0.0&#x27;\nconst dubboSetting = setting.match(\n  interfaceName, { version: interfaceVersion }\n)\nconst dubboService = dubbo =&gt; dubbo.proxyService({\n  dubboInterface: interfaceName,\n  version: &#x27;1.0.0&#x27;,\n  methods: {\n    Hello (who) {\n      return [\n        java.String(who)\n      ]\n    }\n  }\n})\nconst service = {dubboService}\n&#x2F;&#x2F; 实例化Dubbo， 入参主要是名称和 dubbo 接口的设置\nconst dubbo = new Dubbo({\n  application: {name: &#x27;dubbo-node-test&#x27;},\n  register: &#x27;127.0.0.1:2181&#x27;,\n  dubboSetting,\n  service\n})\n\nmodule.exports = dubbo\n\n</code></pre><p>代码就是这么简单， 把 Java 服务里面通过 dubbo 提供出来的接口(包括接口名，接口版本信息，接口方法) 注册一下。<br>\n得到Dubbo 实例之后，调用对应的 service就可以使用。<br>\n如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>await dubbo.service.dubboService.Hello(who)\n</code></pre><p>我们简单写了一个接口：</p>\n<pre class=\"prettyprint language-javascript\"><code>const KoaRouter = require(&#x27;koa-router&#x27;)\nconst dubbo = require(&#x27;.&#x2F;dubbo&#x27;)\nconst router = new KoaRouter({prefix: &#x27;&#x2F;api&#x2F;v1&#x27;})\n\nrouter.use(&#x27;&#x2F;&#x27;)\n\nrouter.get(&#x27;&#x2F;testNodeDubbo&#x27;, async (ctx, next) =&gt; {\n  console.info(&#96;[testNodeDubbo]:==:&gt; start&#96;)\n  let {who} = ctx.request.query\n  const res = await dubbo.service.dubboService.Hello(who)\n  ctx.body = res\n})\n\nmodule.exports = router\n\n</code></pre><p>调用结果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1gidpequnj20zc0fyq45.jpg\" alt><br>\n这样就完成了 node 作为消费者通过 dubbo 去调用 java 的接口了。</p>\n<h2>4. Node.js 通过接口调用 Java 与 通过 Dubbo 调用 Java 的对比</h2>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1hbp8z51mj21fg0kaq7i.jpg\" alt><br>\n这边尝试使用了调用了同样逻辑的 dubbo 和 http 接口， 对比了一下两个实现的返回时间。<br>\n其中红色的是 dubbo 接口， 蓝色的是 http 接口。</p>\n<h4>其他：</h4>\n<p>项目地址：\n<a href=\"https://github.com/yuchenzhen/Java-dubbo-provider\">https://github.com/yuchenzhen/Java-dubbo-provider</a>\n<a href=\"https://github.com/yuchenzhen/Java-dubbo-client\">https://github.com/yuchenzhen/Java-dubbo-client</a>\n<a href=\"https://github.com/yuchenzhen/node-dubbo2-consumer/tree/master\">https://github.com/yuchenzhen/node-dubbo2-consumer/tree/master</a></p>\n</div>","title":"Node.js通过Dubbo2.js调用Java","last_reply_at":"2019-04-03T12:02:23.250Z","good":false,"top":false,"reply_count":1,"visit_count":212,"create_at":"2019-04-02T08:45:55.530Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5ca494c76c1de62dce467889","author_id":"5c4589cc3b948a2b4ab701c9","tab":"ask","content":"<div class=\"markdown-text\"><p>我用model查询返回的model太大了，我现在只知道用JSON.stringfy()和JSON.parse()来回转换，请问还有什么方法可以转换吗</p>\n</div>","title":"请问mongoose的model怎么转成json对象","last_reply_at":"2019-04-03T11:11:03.119Z","good":false,"top":false,"reply_count":0,"visit_count":41,"create_at":"2019-04-03T11:11:03.119Z","author":{"loginname":"TJJ123456","avatar_url":"https://avatars1.githubusercontent.com/u/25629797?v=4&s=120"}},{"id":"5c9c87e799e62a362ff40cce","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0新特性</strong>\n1、支持migrations，可以快速的创建和修改表；\n2、支持rewrite，可以将请求转发到修改过的接口；\n3、支持view逻辑钩子，可以扩展vue逻辑；\n4、支持view视图钩子，可以扩展vue视图；\n5、支持cluster，可以启动多个项目；\n6、支持本地调试，可以将生产环境的请求转发或复制到本地；\n7、支持bin命令，可以快速的处理migration等；</p>\n<p>开源版下载：<a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"【全开源】可视化DIY微信/百度/支付宝小程序saas平台源码","last_reply_at":"2019-04-03T10:38:22.539Z","good":false,"top":false,"reply_count":1,"visit_count":360,"create_at":"2019-03-28T08:37:59.067Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5c9490cb00bcfd7eb2be500a","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0 新特性</strong>\n1、支持migrations，可以快速的创建和修改表\n通过命令./bin/migrate.js make [name] --scope [module]创建migration，然后使用./bin/migrate.js latest执行migration，使用./bin/migrate.js rollback回滚migration，具体migration的用法可以参考knex文档 <a href=\"https://knexjs.org\">https://knexjs.org</a></p>\n<p>2、支持rewrite，可以将请求转发到修改过的接口\n二次开发最大的问题就是如何在保证系统一致性和更新的情况下，二次修改代码。比如我们需要修改app模块，然后我们复制app模块，起名apps，然后修改rewrite.js，添加如下数据，即完成了配置。此时我们请求app模块会全部转发到apps模块。提示：一个模块下前端路由不带/api，后端路由以/api开头</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = {\n    &quot;&#x2F;app&quot;: &quot;&#x2F;apps&quot;,\n    &quot;&#x2F;api&#x2F;app&quot;: &quot;&#x2F;api&#x2F;apps&quot;\n}\n</code></pre><p>3、支持view逻辑钩子，可以扩展vue逻辑\n3.0重要的特性之一，可以很方便到扩展vue前端逻辑。通过调用this.$hook.run(“xxx”, 1, 2)自动加载view_hook目录下hook.js名称为xxx的函数，修改data里面的数据等。</p>\n<p>4、支持view视图钩子，可以扩展vue视图\n3.0重要的特性之二，可以很方便的扩展vue前端视图，通过调用&lt;doodoo-hook name=“xxx” abc=“2”&gt;&lt;/doodoo-hook&gt;实现，当系统发现view_hook目录下，名称是xxx.vue会自动加载到调用的位置</p>\n<p>5、支持cluster，可以启动多个项目\n目前仅支持同一个序列号，同一台服务器启动多个实例，如需多台服务器启动，请联系客服</p>\n<p>6、支持本地调试，可以将生产环境的请求转发或复制到本地\n解决生产环境的bug，是一个很头痛的问题，我们除了有错误监控外，新增加了本地调试功能。本地调试功能可以将线上生产环境的请求转发或者复制到本地系统，这样可以快速的发现和修复bug。线上的已全部集成到所有的系统，线下的命令行工具会随后发布。</p>\n<p>7、支持bin命令，可以快速的处理migration等\n目前支持doodoo.sh和migrate.js命令</p>\n<p><a href=\"https://gitee.com/doodooke/doodoo\">3.0开源版</a><a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"多多客发布 3.0.0-alpha.3开源版，支持微信、百度、支付宝小程序","last_reply_at":"2019-04-03T10:37:34.030Z","good":false,"top":false,"reply_count":1,"visit_count":244,"create_at":"2019-03-22T07:37:47.641Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5ca46b936c1de62dce467702","author_id":"5ca4678731010b2dfbb42c4b","tab":"ask","content":"<div class=\"markdown-text\"><p>抓取 cnode 社区首页的 40 条文章链接\n然后再对 40 条链接发起请求\n然后发现同时请求太多，会返回 503\n我就直接折腾，封装了一个控制 同时请求 的数量的函数，应该是叫 并发控制 吧。\n不过，有点问题，当我设置为 7 个并发时，就少了 7 条返回，设置为 2 条并发时，就少了 2 条返回。\n我想自己封装，不使用其他包\n以下为代码：</p>\n<pre class=\"prettyprint language-js\"><code>const axios = require(&#x27;axios&#x27;);\nconst cheerio = require(&#x27;cheerio&#x27;);\nconst url = require(&#x27;url&#x27;);\n\nconst href = &#x27;https:&#x2F;&#x2F;cnodejs.org&#x27;;\n\n&#x2F;&#x2F; 抓取url\naxios.get(href)\n      .then(res =&gt; {\n        let $ = cheerio.load(res.data);\n        let node = $(&#x27;#topic_list a.topic_title&#x27;);\n        let list = [];\n        node.each((index, value) =&gt; list.push(url.resolve(href, value.attribs.href)));\n        return list;\n      })\n      .then(list =&gt; {\n\t  &#x2F;&#x2F; 7 个并发\n        many(list, 7).then(data =&gt; console.log(data)).catch(err =&gt; console.log(err));\n\n      })\n      .catch(err =&gt; err);\n\n\n&#x2F;&#x2F; 多线程异步,并发\nfunction many (arr, n) {\n  return new Promise((resolve, reject) =&gt; {\n    &#x2F;&#x2F; 多线程统一数据存放\n    let list = [];\n    &#x2F;&#x2F; 正在运行的线程数\n    let thread = 0;\n    &#x2F;&#x2F; 队列\n    let length = 0;\n\n    &#x2F;&#x2F; 单线程异步\n    function queues (arr) {\n      return new Promise((resolve, reject) =&gt; {\n        &#x2F;&#x2F; 队列数据统一存放\n        let datas = [];\n        function queue (arr) {\n          length ++;\n          return new Promise((resolve, reject) =&gt; {\n          axios.get(arr[length-1])\n                .then(res =&gt; {\n                  if (length &lt; arr.length) {\n                    console.log(&#x27;...&#x27; + length);\n                    datas.push(res.data);\n                    return queue(arr).then(() =&gt; resolve());\n                  }\n                  else {\n                    resolve();\n                  }\n      \n      \n                })\n                .catch(err =&gt; reject(err));\n          });\n      \n        }\n      \n        queue(arr).then(() =&gt; resolve(datas))\n      });\n    }\n\n    &#x2F;&#x2F; 多线程创建\n    for (let i = 0; i &lt; n; i ++) {\n      thread++;\n      queues(arr)\n                .then(data =&gt; {\n                  list.push(data);\n                  thread--;\n                  if (thread === 0) {\n\t\t\t\t  &#x2F;&#x2F; 最后一个线程返回数据\n                    resolve(list);\n                  }\n                })\n                .catch(err =&gt; reject(err));\n    }\n\n  });\n}\n</code></pre><p>返回：\n<img src=\"//static.cnodejs.org/FtODHULPfaIfCJFu-FeXF-wUfxbi\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoBs1-kL9wuIwcqqb714k_tRP8Nf\" alt=\"image.png\"></p>\n</div>","title":"并发控制问题","last_reply_at":"2019-04-03T10:29:58.334Z","good":false,"top":false,"reply_count":1,"visit_count":115,"create_at":"2019-04-03T08:15:15.982Z","author":{"loginname":"tingzhong666","avatar_url":"https://avatars0.githubusercontent.com/u/47524168?v=4&s=120"}},{"id":"5ca2f5126c1de62dce466d9f","author_id":"581ae153e90cfbec054d762a","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/103147/1554174860996-48dafaa4-e8f1-483f-9d05-8ccc91028aa5.png#align=left&amp;display=inline&amp;height=443&amp;name=image.png&amp;originHeight=886&amp;originWidth=1790&amp;size=2086701&amp;status=done&amp;width=895\" alt=\"image.png\"></p>\n<p>【Alibaba-TXD 前端小报】- 热门前端技术快报，聚焦业界新视界；不知不觉 2019 年已经过去了 1/4，日新月异的前端技术正在蓬勃发展，<a href=\"https://segmentfault.com/a/1190000018311280\">ES10</a> 都已到来。</p>\n<blockquote>\n<p>欢迎 <a href=\"https://zhuanlan.zhihu.com/txd-team\">订阅</a> &amp; <a href=\"https://github.com/txd-team/monthly/issues\">投稿</a>\n本期小编：<a href=\"https://github.com/happyliuliu\">玙璠</a></p>\n</blockquote>\n<h3>学习专栏</h3>\n<h4>2019 年前端技术会议</h4>\n<p>裕波列出了一份前端技术会议的<a href=\"https://www.yuque.com/itchina110/giku37/xdzuak\">清单</a>，涵盖国内和海外的重大前端相关的技术会议</p>\n<h4>微软前端训练营</h4>\n<p>微软推出另一个前端的学习路径规划，官方提供的<a href=\"https://github.com/Microsoft/frontend-bootcamp\">代码仓库</a>将一步一步带你走进前端技术领域，囊括基础的 HTML/CSS/JS 学习、TypeScript 强类型、React/Redux 学习和实践等。</p>\n<h3>新闻快报</h3>\n<h4>阿里开源 Flutter 应用框架 Fish Redux</h4>\n<p><a href=\"https://github.com/alibaba/fish-redux\">Fish Redux</a> 框架是基于 Redux 数据管理的组装式 Flutter 应用框架，适合用于构建中大型的复杂应用，解决了集中状态管理和UI组件化等问题，将集中，分治，复用，隔离做的更进一步。</p>\n<h4>Handtrack.js 搞定手部动作跟踪</h4>\n<p>这是一个经过训练的产生的开源模型，而不需要用户自己训练。它隐藏了模型的加载步骤，允许用户在没有任何 ML 经验的情况下检测图像中的手，可以直接在 Web 应用使用该库，<a href=\"https://github.com/eduardolundgren/tracking.js\">传送门</a>。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440898-750a723a-7f77-4a2b-8be6-4657f6a1e5d5.gif#align=left&amp;display=inline&amp;height=194&amp;name=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.gif&amp;originHeight=240&amp;originWidth=320&amp;size=3646259&amp;status=done&amp;width=259\" alt=\"人工智能.gif\"></p>\n<h4>小程序多端框架</h4>\n<p>如今小程序的发展如日中天，很多公司的业务也都慢慢转向小程序，同时很多应用需要同时兼顾多个小程序平台，所以就有了上层开发框架或者脚手架来优化 DSL 来提高开发效率。其中凹凸实验室从开发体验、兼容性、接入成本、工具链等多个方面对小程序的的多端框架进行了全面的<a href=\"https://juejin.im/post/5c90eb366fb9a070d4199cc9\">测评</a>，如果准备入坑，可以事先了解一下。</p>\n<h4>TWA 让你的 PWA 进入应用商店</h4>\n<p>TWA（Trusted Web Activity）的发布，是将 Native 的技术扩展到 Web App，将 PWA 站点打包为 Native App 放入应用商店，用户可以在应用商店中搜索安装 PWA 应用，相比国外，PWA 在国内并非很流行，但这并不代表这个技术就不关键。未来可以考虑如何将该技术融入实践中来，<a href=\"https://developers.google.com/web/updates/2019/02/using-twa\">传送门</a>，这篇<a href=\"https://www.infoq.cn/article/XTE9WzSL11iHmW*WBozi\">文章</a>也有全面的解析。</p>\n<h4>Storybook 5.0 正式发布</h4>\n<p>Storybook 是一个比较受欢迎的 UI 组件库，为各种视图层（如 React、Vue、Angular、React Native、Ember）提供了结构化的 UI 开发、测试和文档。Storybook 5.0 是目前为止发布的最大的一个版本，新版本的内容包括：全新的开发体验；带有主题的组件库；改进的前端插件架构；全新的<a href=\"https://storybook.js.org/\">官网</a>。</p>\n<h4>Node.js 和 JS 基金会合并为 OpenJS 基金会</h4>\n<p>Node.js 基金会和 JS 基金会宣布合并为 OpenJS 基金会，将提供一个中立的组织来托管项目并协助资助有益于生态系统的活动，简化基金会日常运营的同时满足个基础架构、技术和营销需求，为 Node.js 和 JavaScript 提供更光明的未来，这也是 JavaScript 发展中的一大步。</p>\n<h4>5G 来了</h4>\n<p>从 2G 的发展，到 3G 的的成熟，再到 4G 落地，继而迎接 5G 时代的全面到来。5G 具有极快的传输速度、更高的网络容量、信息可及时触达等特点，也就是高速率、多连体、低时延。这些优势可带动广泛的行业发展，如物联网、视频、全息技术以及无人驾驶等，让我们，拭目以待。</p>\n<h4>996.ICU</h4>\n<p>相当火爆的 github 项目 <a href=\"https://github.com/996icu/996.ICU\">996.ICU</a>，由 IT 工作者对工作制度的反抗，以谋求自己的合法权益的一种特别的方式。不得不感叹的是，随着时代及技术的发展，无产阶级的联合方式也在发生着变化。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440891-46104a73-a778-4813-b116-2d2840e6795f.gif#align=left&amp;display=inline&amp;height=168&amp;name=%E5%8A%A0%E7%8F%AD.gif&amp;originHeight=104&amp;originWidth=129&amp;size=19061&amp;status=done&amp;width=208\" alt=\"加班.gif\"></p>\n<h4>TSLint -&gt; ESLint</h4>\n<p>继和 Babel 合作，使 Babel 支持编译 TS 语法后，TypeScript 团队又发布了新的 Roadmap，将使用 ESLint 来进行 TS 语法的静态类型检查，统一开发体验。TSLint 和 ESLint 团队也纷纷发文，公布未来的计划，TSLint 在被完全集成之前，会保持维护状态，ESLint 中推荐使用 typescript-eslint 来支持 TS 语法的静态类型检查，具体见 <a href=\"https://github.com/palantir/tslint/issues/4534\">TSLint Roadmap</a>、<a href=\"https://eslint.org/blog/2019/01/future-typescript-eslint\">The future of TypeScript on ESLint</a></p>\n<h3>工具推荐</h3>\n<h4><a href=\"https://github.com/alexfoxy/laxxx\">Animations when you scroll</a></h4>\n<ul>\n<li>将滚动与动画相结合，使页面更有灵性</li>\n<li>支持在 DOM、React、VUE 中使用</li>\n<li>支持多种动画参数配置</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440895-2c7ea1b1-3e3c-428b-9c40-fa08b863168c.gif#align=left&amp;display=inline&amp;height=259&amp;name=lax.gif&amp;originHeight=259&amp;originWidth=320&amp;size=634366&amp;status=done&amp;width=320\" alt=\"lax.gif\"></p>\n<h4>You Dont Need 系列</h4>\n<p>You Dont Need 系列教程目的在于让读者回归基础，在不依赖一些主流的 util 库的情况下，自己动手去实现库里面提供的核心功能；很多情况下，一些 util 库占用了大量的体积，而且业务中实际使用的部分很少，如果能够手工去实现其中使用到的一些方法，就可以轻松通过移除三方库来提高加载速度了。（然而上规模的项目中，依然建议使用统一的 util 库）</p>\n<ul>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-JavaScript\">You-Dont-Need-JavaScript</a> 介绍了一些常用的组件、动效、甚至功能，在不通过编写 JavaScript 代码的前提下去实现它！</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-GUI\">You-Dont-Need-GUI</a> 许多场景下，我们使用命令交互的方式去操作机器（如文件、进程等处理），能大幅提高工作效率。</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-Momentjs\">You-Dont-Need-Momentjs</a> 介绍了 moment.js 对时间处理的核心功能实现。（通常情况下，我们还是需要一个时间处理库，推荐使用体积更小的 date-fns / dayjs）。</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\">You-Dont-Need-Lodash-Underscore</a> 常用的一些 util 方法的 JavaScript 实现。</li>\n<li><a href=\"https://github.com/nefe/You-Dont-Need-jQuery\">You-Dont-Need-jQuery</a> 去除 jQuery 的一些 Native JavaScript 的方案，一步一步替换 jQuery 的 API。</li>\n</ul>\n<h4>TypeScript To WebAssembly</h4>\n<p>通常我们都需要将 TypeScript 编译成 ES5 的代码，才能在浏览器中正常运行，<a href=\"https://github.com/AssemblyScript/assemblyscript\">assemblyscript</a> 是一款 TypeScript To WebAssembly 的编译器，通过 Webassembly 运行编译后的二进制代码。</p>\n<h3>热门文章</h3>\n<h4><a href=\"https://zhuanlan.zhihu.com/yujiangshui\">我在淘宝做前端的这三年</a></h4>\n<p>红了樱桃，绿了芭蕉。文章将在淘宝的三年时光折射为入职、职业规划、招聘、晋升、离职等与我们息息相关的经验分享，值得品读。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MzI5MTA4ODA3NQ==&amp;mid=2247483710&amp;idx=1&amp;sn=cce855fd797f68ef77da424a7809500b&amp;chksm=ec14b29adb633b8ccd4cab9a84adfd89014c96792c799b8501bdaf99bfc3c916dd298ffd62e3&amp;mpshare=1&amp;scene=2&amp;srcid=&amp;from=timeline&amp;ascene=2&amp;devicetype=androi\">前端专业方向的尽头</a></h4>\n<p>驽马十驾,功在不舍。或是走一条纯专业的探索之路，或是趋向技术管理，这些都是技术人的选择与坚持，也会拥有独一无二的风景。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651014404&amp;idx=2&amp;sn=7ed7c965c10af5463b0ffadd9661ab61&amp;chksm=bdbebd578ac93441467b1d81bc81141f2cecbee0b35dd625c62156d8f6abd33d1bea8661bea6&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1552918479&amp;ascene=7&amp;devic\">2019年大前端技术趋势深度解读</a></h4>\n<p>念过去，望未来。前端的发展日新月异，坚持学习的同时也要保持思辨和平和。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/137059/1554173440911-9bd825a2-0664-4e96-b300-12a855a34e4a.png#align=left&amp;display=inline&amp;height=378&amp;name=image.png&amp;originHeight=1044&amp;originWidth=1080&amp;size=1149092&amp;status=done&amp;width=391\" alt=\"image.png\"></p>\n</div>","title":"前端小报 - 201903月刊","last_reply_at":"2019-04-03T10:15:38.768Z","good":false,"top":false,"reply_count":1,"visit_count":287,"create_at":"2019-04-02T05:37:22.144Z","author":{"loginname":"x-cold","avatar_url":"https://avatars1.githubusercontent.com/u/6903313?v=4&s=120"}},{"id":"5ca0d30b99e62a362ff41ad5","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><h4>上一贴被素质低下的人谩骂，建议cnodejs增加黑名单功能</h4>\n<h1>仓库地址 <a href=\"https://github.com/996icu/996.ICU\">https://github.com/996icu/996.ICU</a></h1>\n<p>996ICU最近的热门事件，因为比较敏感，都担心被企业拉入黑名单，在cnodejs居然只有我一个人敢发贴，我不入地狱谁入地狱，为了广大互联网从业人员，豁出去了，反正我也不打算能写程序到35岁\n工作 996，生病 ICU，说不定ICU的机会都没有，赚那么多钱有用吗？要敢于反抗，不畏强权，即使被生活所迫也不要放弃说“不”的权利，我们热爱工作，我们更热爱生活，我们要陪家人、我们要有时间去谈恋爱、去感受生命的美好\n<strong>程序猿的责任心不容质疑，我可以自愿007，但绝不愿强制996</strong></p>\n<h2>到2019/03/31 21:48，已经达到github star排行榜第四名，已经超过了linux、node、react等项目</h2>\n<p><img src=\"//static.cnodejs.org/Fre1-VOz_Q6R-QZbtifrX-M8Yjp8\" alt=\"QQ图片20190331214609.png\"></p>\n<h2>这些关注996工作制的程序员中，有程序员大牛吗？当然有！我们把粉丝数排名前10的程序员筛了出来。</h2>\n<p><img src=\"//static.cnodejs.org/FtUSgXzvDKwiS2zd78ME8j7bpAsH\" alt=\"0LcMty70Gl.jpeg\">\n排名第一的是一个熟悉的面孔，轮子哥！另外有来自腾讯的Coco，来自滴滴的singwhatiwanna，技术博主颜海镜等，这些人都在关注996。在39987个Star了该repos的程序员中，粉丝数大于1000的有47人，大于500的有110，大于100的有598人。说明还是有很多有影响力的程序员在关注996工作制。\n来源： <a href=\"https://www.yidianzixun.com/article/0LcMtyRT?title_sn=0\">https://www.yidianzixun.com/article/0LcMtyRT?title_sn=0</a></p>\n<p>各行各业都有被压榨，都有在反抗，比如富士康接二连三的跳楼，这些人用命换来了大量工厂的遵纪守法，在这个风口，十几万程序猿正在进行一项伟大的事业，为中国的程序猿们争取合法正当权益，让我们加油！</p>\n<p><strong>法律从来没说给钱多就允许违法，正义可能迟到但从不缺席</strong></p>\n<h2>请文明发表意见</h2>\n</div>","title":"重新开贴，讨论最近热门996ICU，工作 996，生病 ICU，说不定ICU的机会都没有，赚那么多钱有用吗？","last_reply_at":"2019-04-03T08:48:08.509Z","good":false,"top":false,"reply_count":12,"visit_count":950,"create_at":"2019-03-31T14:47:39.933Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5ca4681f6c1de62dce4676dd","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>在nodejs中IO操作是使用线程池进程异步操作的，那么假如我向nodejs请求读取一个大文件，是不是会持续占用线程导致降低服务器处理其他请求的能力。\n在Eggjs中有什么机制来避免大文件访问造成服务器性能下降的办法吗</p>\n</div>","title":"关于Nodejs的IO异步操作以及eggjs处理耗时任务的疑问","last_reply_at":"2019-04-03T08:43:50.170Z","good":false,"top":false,"reply_count":1,"visit_count":123,"create_at":"2019-04-03T08:00:31.009Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5ca464fd6c1de62dce467688","author_id":"5ca4639c31010b2dfbb42c0a","tab":"ask","content":"<div class=\"markdown-text\"><p>刚开始的时候，node main.js是正常的，接口也可以正常返回，但是放着一段时间，大概5~10分钟，就会报错 read ECONNRESET，然后重新运行node main.js又可以了，间隔一段时间又是同样的问题。node小白，求大神指点一下<img src=\"//static.cnodejs.org/FoR7GugN2D91pb0aKqn6TxNEl_Fu\" alt=\"error.png\"></p>\n</div>","title":"node运行接口，刚开始是正常的，间隔一段时间后变成 read ECONNRESET","last_reply_at":"2019-04-03T07:47:09.354Z","good":false,"top":false,"reply_count":0,"visit_count":108,"create_at":"2019-04-03T07:47:09.354Z","author":{"loginname":"yjl000","avatar_url":"https://avatars0.githubusercontent.com/u/25833497?v=4&s=120"}},{"id":"5ca4384e31010b2dfbb42a6b","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>初学node，听说他是单线程的，只能使用一个核心，如果CPU是多核心的，那么只能用一个核心，其他核心无法使用。对吧？</p>\n<p>发现了一个问题。本来是想看看精确计时的问题，但是在死循环的时候，看了一下CPU的使用情况，发现四个核心都利用起来了。\n反复试验了几次都是这样，没有其他软件运行。不知道是怎么回事。</p>\n<blockquote>\n<p>var i=0;\nvar j=0;</p>\n</blockquote>\n<p>var star = (new Date()).getTime();  //普通计时\nvar star2 = time();  //精确计时\nvar star3 = time();  //精确计时</p>\n<p>while (true){\ni++;j++;</p>\n<pre class=\"prettyprint\"><code>var t = time() - star2;\nvar msg = i + &#x27;_&#x27; + (new Date()).getTime() + &#x27;_&#x27; + time() + &#x27;_&#x27; +t;\n&#x2F;&#x2F;计算每循环100次需要的时间，运行结果可得，时间并不一致\nif (j==100){\n    var t2 = (new Date()).getTime() - star;\n    var t3 = time() - star3;\n    console.log(msg + &#x27;_&#x27; + t2+ &#x27;_&#x27; + t3); &#x2F;&#x2F;每百次用时\n    star = (new Date()).getTime();\n    star3 = time();\n    j=0;\n}\nelse {\n    console.log(msg);\n}\n\nstar2 = time();\n</code></pre><p>}\nfunction time(){\nvar diff = process.hrtime();\nreturn diff[0] * 1000 + diff[1] / 1e6; // nano second -&gt; ms</p>\n<p>}</p>\n<p><img src=\"//static.cnodejs.org/FgQ2pWQIjYgzNYTGpxGjbV4YePfS\" alt=\"time10.png\"></p>\n<p>开始运行，四个核的使用率都上来了，关闭运行，四个核的使用率都下来了。</p>\n<p>是不是我理解错了？</p>\n</div>","title":"不是说node不能利用多核心CPU吗？","last_reply_at":"2019-04-03T07:15:15.863Z","good":false,"top":false,"reply_count":7,"visit_count":281,"create_at":"2019-04-03T04:36:30.928Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5ca1b8206c1de62dce46688d","author_id":"5a3b17649807389a1809f5a5","tab":"ask","content":"<div class=\"markdown-text\"><p>mongo 同步数据到 es上，尽可能的不改现有代码？各位怎么做的？</p>\n</div>","title":"mongo 同步数据到 es上，尽可能的不改现有代码？各位怎么做的？","last_reply_at":"2019-04-03T06:19:42.632Z","good":false,"top":false,"reply_count":1,"visit_count":308,"create_at":"2019-04-01T07:05:04.123Z","author":{"loginname":"Sxy97","avatar_url":"https://avatars3.githubusercontent.com/u/24429847?v=4&s=120"}},{"id":"5ca2dc5631010b2dfbb4222f","author_id":"57b99bc2dcaeb5d932db220a","tab":"share","content":"<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能，此项目可能会涉及到网络、操作系统、编译原理、工程开发等知识，欢迎贡献。\nGithub: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/README.md\">带宽与延迟</a>\n<ul>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/TCP%E5%8D%8F%E8%AE%AE%E7%BB%86%E8%8A%82.md\">TCP协议细节</a></li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/README.md\">静态资源</a>\n<ul>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>离线应用资源</li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/Webpack.md\">Webpack</a></li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/CDN.md\">CDN</a></li>\n</ul>\n</li>\n<li>响应式编程\n<ul>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/PubSub%E6%96%B9%E5%BC%8F.md\">Pub/Sub方式</a></li>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/Vue%E6%96%B9%E5%BC%8F.md\">Vue的方式</a></li>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E8%84%8F%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6.md\">脏检查机制</a></li>\n<li>Rx</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li><a href=\"/HTTPS%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/TLS%E5%8E%9F%E7%90%86.md\">TLS原理</a></li>\n<li><a href=\"/HTTPS%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D.md\">性能影响</a></li>\n</ul>\n</li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/README.md\">高性能JavaScript</a>\n<ul>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/V8%E4%B8%8EJIT.md\">V8与JIT</a></li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md\">内存管理</a></li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/GC%E6%9C%BA%E5%88%B6.md\">GC机制</a></li>\n<li>内存泄露</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly\n<ul>\n<li>编译原理</li>\n<li>性能提升点</li>\n<li>应用场景</li>\n</ul>\n</li>\n<li>PWA与离线应用</li>\n<li>即时应用与P2P\n<ul>\n<li>UDP协议</li>\n<li>WebRTC</li>\n<li>WebSocket</li>\n<li>其他解决方案</li>\n</ul>\n</li>\n<li>Node.js性能优化\n<ul>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.md\">多进程架构</a></li>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Node%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B.md\">Node中的多进程</a></li>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%BC%82%E6%AD%A5IO.md\">异步I/O</a></li>\n<li>Buffer与Stream</li>\n<li>C++扩展</li>\n</ul>\n</li>\n<li>云计算相关\n<ul>\n<li>三大算法</li>\n<li>虚拟技术</li>\n<li>分布式集群</li>\n<li>大数据计算</li>\n</ul>\n</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>","title":"性能优化知识与实践整理","last_reply_at":"2019-04-03T05:59:38.102Z","good":false,"top":false,"reply_count":0,"visit_count":315,"create_at":"2019-04-02T03:51:50.977Z","author":{"loginname":"laoqiren","avatar_url":"https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"}},{"id":"5c9843bffd41137eb76612fc","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>后台有一个接口，做一分钟内只能被调用一次，多余的请求被忽略。请问有什么模块或者什么方法可以来实现吗</p>\n</div>","title":"express接口做1分钟只能请求一次的限制","last_reply_at":"2019-04-03T05:09:48.888Z","good":false,"top":false,"reply_count":7,"visit_count":820,"create_at":"2019-03-25T02:58:07.038Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5ca42f696c1de62dce46744a","author_id":"5ca42bf931010b2dfbb42a1c","tab":"share","content":"<div class=\"markdown-text\"><p>HTTP Catcher 是一个 iOS 平台上的 http 调试工具，一般我们查看移动设备上的 http 请求需要连接电脑上的代理应用，通过代理应用才能查看请求日志。使用 HTTP Catcher 可以在 iOS 设备上直接查看请求内容，同时支持 https 数据解密。</p>\n<h1>功能</h1>\n<ul>\n<li>实时记录 HTTP 和 WebSocket 请求</li>\n<li>支持解密 HTTPS</li>\n<li>请求过滤</li>\n<li>支持远程代理</li>\n<li>图片预览</li>\n<li>HTML, JavaScript, CSS 格式化预览</li>\n<li>二进制数据查看</li>\n<li>自定义 Hosts</li>\n<li>重放请求</li>\n<li>黑名单</li>\n</ul>\n<p>分享一个比较常用的场景：\n在配合服务端接口调试的时候，会被要求重发请求，有时候需要页面多次跳转才能发送相应的请求，使用重放功能会简化这个工作。</p>\n<p>目前应用还在持续开发中，期待大家使用！</p>\n<p><a href=\"https://itunes.apple.com/us/app/http-catcher/id1445874902?l=zh&amp;ls=1&amp;mt=8\">Link to App Store</a></p>\n<p><a href=\"https://testflight.apple.com/join/4Qt2lIm5\">Link to TestFight</a></p>\n</div>","title":"分享 iOS 平台下的 http 抓包应用 - HTTP Catcher","last_reply_at":"2019-04-03T03:58:33.820Z","good":false,"top":false,"reply_count":0,"visit_count":112,"create_at":"2019-04-03T03:58:33.820Z","author":{"loginname":"imxiaozhi","avatar_url":"https://avatars1.githubusercontent.com/u/7193241?v=4&s=120"}},{"id":"5ca42ada31010b2dfbb42a0b","author_id":"5c0e2cc3f3d48d2397c0fad9","tab":"share","content":"<div class=\"markdown-text\"><h1>Clipic.js</h1>\n<blockquote>\n<p>Clipic.js插件可以为移动端提供头像上传并裁剪成指定尺寸，用原生js开发的，轻量级，包含html跟css，不到8kb。先上一张效果图，或者点此链接体验：<a href=\"https://teojs.github.io/clipic/\" title=\"Clipic.js\">https://teojs.github.io/clipic/</a></p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/6/16951ba160c5fc6d?w=300&amp;h=519&amp;f=gif&amp;s=1635316\" alt=\"eg\"></p>\n<h2>Github地址</h2>\n<p><a href=\"https://github.com/teojs/clipic\">https://github.com/teojs/clipic</a></p>\n<h2>使用方法</h2>\n<h3>支持npm方式</h3>\n<pre class=\"prettyprint language-bath\"><code>$ npm install clipic\n</code></pre><h3>支持cdn 引入</h3>\n<pre class=\"prettyprint language-html\"><code>&lt;script src=&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;clipic&#x2F;dist&#x2F;clipic.min.js&quot;&gt;&lt;&#x2F;script&gt;\n</code></pre><h3>在vue项目中使用</h3>\n<pre class=\"prettyprint language-html\"><code>&#x2F;&#x2F; xxx.vue\n&lt;template&gt;\n  &lt;img :src=&quot;base64&quot; &#x2F;&gt;\n  &lt;input type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image&#x2F;*&quot; @change=&quot;uploadImg&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import Clipic from &#x27;clipic&#x27;\n  const clipic = new Clipic()\n  export default {\n    data () {\n      return {\n        base64: &#x27;&#x27;\n      }\n    }\n    methods: {\n      uploadImg(event) {\n        const files = event.files\n        const reader = new FileReader()\n        reader.readAsDataURL(files[0])\n        reader.onload = img =&gt; {\n          clipic.getImage({\n            width: 500,\n            height: 400,\n            src: img.target.result,\n            onDone: base64 =&gt; {\n              this.base64 = base64\n            }\n          })\n        }\n        event.value = &#x27;&#x27;\n      }\n    }\n  }\n&lt;&#x2F;script&gt;\n</code></pre><p>普通项目的使用可以看作者的<a href=\"https://github.com/teojs/clipic/blob/master/index.html\">demo</a></p>\n<h2>参数说明</h2>\n<ul>\n<li><code>width:Number</code> (默认：500) – 裁剪宽度</li>\n<li><code>height:Number</code> (默认：500) – 裁剪高度</li>\n<li><code>ratio:Number</code> (可选) – 裁剪的比例，当传入<code>ratio</code>时<code>width/height</code>将无效</li>\n<li><code>src:String</code> (必传) – 需要裁剪的图片，可以是图片链接，或者 base64</li>\n<li><code>type:String</code> (默认：jpeg) – 裁剪后图片的类型，仅支持 jpeg/png 两种</li>\n<li><code>quality:Number</code> (默认：0.9) – 压缩质量</li>\n<li><code>buttonText:Array</code> (默认：[‘取消’, ‘重置’, ‘完成’]) – 底部三个按钮文本</li>\n</ul>\n</div>","title":"移动端上传头像并裁剪 - Clipic.js","last_reply_at":"2019-04-03T03:39:06.951Z","good":false,"top":false,"reply_count":0,"visit_count":111,"create_at":"2019-04-03T03:39:06.951Z","author":{"loginname":"Cheesenx","avatar_url":"https://avatars2.githubusercontent.com/u/25993112?v=4&s=120"}},{"id":"5c9c477d484eeb3634157d7b","author_id":"5c9c474299e62a362ff40b3c","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs怎么执行远程服务器的bat脚本，求大佬</p>\n</div>","title":"nodejs怎么执行远程服务器的bat脚本","last_reply_at":"2019-04-03T03:11:36.979Z","good":false,"top":false,"reply_count":5,"visit_count":366,"create_at":"2019-03-28T04:03:09.310Z","author":{"loginname":"IAmYuanZhao","avatar_url":"https://avatars2.githubusercontent.com/u/38496544?v=4&s=120"}},{"id":"5b7ac9c7c52ad1482eb940bf","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"ask","content":"<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>","title":"Egg.js现在用的人多吗？那些公司在用有知道的吗？","last_reply_at":"2019-04-02T23:47:02.015Z","good":false,"top":false,"reply_count":87,"visit_count":8644,"create_at":"2018-08-20T14:01:43.981Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5c1c425c76c4964062a1c0ef","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>推荐一个前端导航网站，记录了各种关于前端的网址，可以直接在对应社区查找问题。\n喜欢的话赶快收藏一波吧 ^^\n网站地址： <strong><a href=\"https://www.frontendjs.com/\">https://www.frontendjs.com/</a></strong></p>\n<p><img src=\"//static.cnodejs.org/Fk1zwq8EO9Ugzovv-D1T5-GUnuIy\" alt=\"3898986698-5c05daee066b9_articlex.png\"></p>\n</div>","title":"前端导航网址分享，觉得有帮助的可以收藏下","last_reply_at":"2019-04-02T15:17:57.571Z","good":false,"top":false,"reply_count":10,"visit_count":1613,"create_at":"2018-12-21T01:31:08.779Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5ca3724631010b2dfbb427d5","author_id":"56d01c25dec0748461ebb8e6","tab":"share","content":"<div class=\"markdown-text\"><p>WebStorm 有很方便的 Debug 功能，如果是普通 node.js 项目的话，参考 <a href=\"https://www.jetbrains.com/help/webstorm/running-and-debugging-node-js.html\">WebStorm 官方的 Debug 说明</a> 配置即可。</p>\n<p>由于 node.js 7+ 后都使用 <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\">Inspector</a> 来实现 Debug， 因此需要注意最低保证 node.js 版本 &gt;= 7 及 JetBrains WebStorm 版本 &gt;= 2017.1+。</p>\n<p>鉴于 js 项目的多样性，实际项目中，经常会使用 Babel 或者 TypeScript 编译，特别记录下 <a href=\"https://avnpc.com/pages/webstorm-debug-typescript-babel-project\">WebStorm 在使用 TypeScript 或 Babel 时的 Debug 配置</a>以备忘。 下文以 node.js v10 及 WebStorm 2019.1 为例。</p>\n<h2>WebStorm Debug 基于 Babel 的项目</h2>\n<p>虽然 babel 有 <a href=\"https://babeljs.io/docs/en/babel-node\">babel-node</a> 可以直接运行未编译代码，但并不推荐在 Debug 中使用 babel-node 直接替换 node。这是由于 babel-node <a href=\"https://github.com/babel/babel/blob/master/packages/babel-node/src/babel-node.js\">只是一个 node cli 的简单封装</a>，在 babel-node 的一些早期版本中， 并未加入 <code>--inspect-brk</code> 等 Debug 所需参数的支持，可能会引发无法打断点或 Debug 进程无法退出等问题。</p>\n<p>首先确认好 babel 的安装情况</p>\n<p>对于 Babel 7</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev @babel&#x2F;core @babel&#x2F;cli @babel&#x2F;register\n</code></pre><p>对于 Babel 6</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev babel-core babel-cli babel-register\n</code></pre><p>推荐的 Debug 配置如下：</p>\n<ol>\n<li>打开 <code>Run/Debug Configuration</code> 窗口</li>\n<li>新建一个配置，类型选择 <code>Node.js</code></li>\n<li><code>Node Interpreter</code> 选择本地安装的 node 路径</li>\n<li><code>Node Parameters</code> 中通过 <code>-r</code> 参数，在 node 启动时额外加载 babel 的运行时， 即\n<ul>\n<li>如果是 Babel 7, 填入 <code>-r @babel/register</code></li>\n<li>如果是 Babel 6， 填入 <code>-r babel-register</code></li>\n</ul>\n</li>\n<li><code>Working Directory</code> 中填入当前项目的根目录</li>\n<li><code>JavaScript file</code> 中填入要 Debug 的 js 文件的相对路径 （相对项目根目录）。如果是类似 Express 之类的 Web 服务，填入服务启动入口文件相对路径</li>\n</ol>\n<p>如下图</p>\n<p><img src=\"https://static.avnpc.com/blog/2019/webstorm_debug_babel.png\" alt=\"WebStorm debug Babel\"></p>\n<h2>WebStorm Debug 基于 TypeScript 的项目</h2>\n<p>和 Babel 类似， TypeScript 的项目也可以用同样的思路进行 Debug</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev typescript ts-node\n</code></pre><p>配置如下</p>\n<ol>\n<li>打开 <code>Run/Debug Configuration</code> 窗口</li>\n<li>新建一个配置，类型选择 <code>Node.js</code></li>\n<li><code>Node Interpreter</code> 选择本地安装的 node 路径</li>\n<li><code>Node Parameters</code> 填入 <code>-r ts-node/register</code></li>\n<li><code>Working Directory</code> 中填入当前项目的根目录</li>\n<li><code>JavaScript file</code> 中填入要 Debug 的 ts 文件的相对路径</li>\n</ol>\n<p>如图</p>\n<p><img src=\"https://static.avnpc.com/blog/2019/webstorm_debug_typescript.png\" alt=\"WebStorm debug TypeScript\"></p>\n</div>","title":"使用 WebStorm Debug 基于 TypeScript 或 Babel 的 node.js 项目","last_reply_at":"2019-04-02T14:31:34.390Z","good":false,"top":false,"reply_count":0,"visit_count":177,"create_at":"2019-04-02T14:31:34.390Z","author":{"loginname":"AlloVince","avatar_url":"https://avatars3.githubusercontent.com/u/176019?v=4&s=120"}},{"id":"5ca3359e31010b2dfbb426c4","author_id":"556150874eb040084cfe5dcb","tab":"ask","content":"<div class=\"markdown-text\"><p>在 <code>koa-compose</code> 中 <a href=\"https://github.com/koajs/compose/blob/4.1.0/index.js#L42\">return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</a>为什么需要 <code>Promise.resolve()</code></p>\n<p>a:  在 <a href><code>koa/application.js</code></a> 中</p>\n<p><code>fnMiddleware(ctx).then(handleResponse)</code>, 可知需要一个 <code>Promise</code></p>\n<p>但是 改成如下也是可以工作的</p>\n<pre class=\"prettyprint\"><code>return function (context, next) {\n    &#x2F;&#x2F; last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      \n\n      &#x2F;&#x2F; 添加 对 i === 0 判断是否是 fnMiddleware(ctx).then\n      if( i === 0) {\n       fn = (...args) =&gt; {\n\t\t\tlet res = null;\n\t\t\t&#x2F;&#x2F; 1楼提出的改善\n\t\t\ttry{\n\t\t  \t\tres = Promise.resolve(middleware[0](...args))\n\t\t\t} catch(e) {\n\t\t\t\tres = Promise.reject(e);\n\t\t\t}\n\t\t\treturn res;\n\t   }\n      }\n      if (!fn) return Promise.resolve()\n      try {\n        return fn(context, dispatch.bind(null, i + 1));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n</code></pre><p>b: 如果是 middleware 中 需要 <code>await next</code> 的话, 一定是一个 <code>async</code> 函数, 所以也不需要<code>Promise.resolve()</code></p>\n<p>c: 如果 middleware 是一个同步函数, 也不需要 <code>Promise.resolve()</code></p>\n<p>还有哪些情况我没有考虑到的?</p>\n</div>","title":"koa-compose 为什么需要  Promise.resolve(fn(context, dispatch.bind(null, i + 1)));","last_reply_at":"2019-04-02T11:56:37.536Z","good":false,"top":false,"reply_count":3,"visit_count":207,"create_at":"2019-04-02T10:12:46.903Z","author":{"loginname":"xinshangshangxin","avatar_url":"https://avatars1.githubusercontent.com/u/8779091?v=4&s=120"}},{"id":"5ab3166be7b166bb7b9eccf7","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>说明</h1>\n<p>2017-12-14 我发了一篇文章《没用过Node.js，就别瞎逼逼》是因为有人在知乎上黑Node.js。那篇文章的反响还是相当不错的，甚至连著名的hax贺老都很认同，下班时读那篇文章，竟然坐车的还坐过站了。大家可以很明显的感到Node.js的普及度还不够，还存很多误解。甚至说很多小白用户也得不到很好的学习。大神都功成身退，书也跟不上，大部分都是2013年左右的，Node.js版本都是基于v0.10左右的，现在已经v9了。想想也是有点可惜，使用如此广泛的Node.js被大家默认，却没人来科普。</p>\n<p>反思之后，我就想准备一个科普的Live，于是就有了《狼叔：如何正确学习 Node.js？》，相信能够对很多喜欢Node.js的朋友有所帮助。Live已完成目前1200多人，230人评价，平均4.8+，还算是一个比较成功的Live。现整理出来，希望对更多朋友有用。</p>\n<ul>\n<li>感谢 <a href=\"/user/justjavac\">@justjavac</a> 大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址，声音版</a></li>\n</ul>\n<h1>【全文】狼叔：如何正确的学习Node.js</h1>\n<p>Live 简介</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容，目录</p>\n<p>Part 0 ：Node.js简介</p>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<p>Part 1前言：学习 Node.js 的三个境界</p>\n<p>Part 2准备：如何学习Node.js</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</p>\n<p>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</p>\n<p>Part 5答疑：回答大家的问题</p>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，希望大家多多理解和支持。</p>\n<h2>Part 0 ：Node.js简介</h2>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<h3>a）Node.js简介</h3>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href=\"https://github.com/ry\">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<h3>b）什么是Node.js？</h3>\n<p>按照 <a href=\"https://nodejs.org/en/\">Node.js官方网站主页</a> 的说法:</p>\n<pre class=\"prettyprint\"><code>Node.js® is a JavaScript runtime built on Chrome&#x27;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient. Node.js&#x27; package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n</code></pre><p>从这段介绍来看，解读要点如下</p>\n<ul>\n<li>Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境</li>\n<li>构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本</li>\n<li>事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的</li>\n<li>使用 <code>npm</code> 作为包管理器，目前 <code>npm</code> 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+</li>\n</ul>\n<p>大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。</p>\n<h3>c）基本原理</h3>\n<p>下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。</p>\n<p><img src=\"//static.cnodejs.org/Fh2MIT1r4YStGl9ZEEzt7N4lEbqX\" alt=\"14912763353044.png\"></p>\n<p>核心概念</p>\n<ul>\n<li>Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 <code>Chrome</code> 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</li>\n<li>Event Loop 事件循环（由 <code>libuv</code> 提供）</li>\n<li>Thread Pool 线程池（由 <code>libuv</code> 提供）</li>\n</ul>\n<p>梳理一下</p>\n<ul>\n<li>Chrome V8 是 JavaScript 引擎</li>\n<li>Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</li>\n<li>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li>\n<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li>\n<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行</li>\n<li>CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务</li>\n<li>将等待中的 I/O 任务放到 Event Loop 里</li>\n<li>由 Event Loop 将 I/O 任务放到线程池里</li>\n<li>只要有资源，就尽力执行</li>\n</ul>\n<p>我们再换一个维度看一下</p>\n<p><img src=\"//static.cnodejs.org/FkTMjCoX4xyL0rJtmm7oBc6V0i8W\" alt=\"14992384974942.png\"></p>\n<p>核心</p>\n<ul>\n<li>Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因）</li>\n<li><code>libuv</code> 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行</li>\n</ul>\n<p>在解决并发问题上，异步是最好的解决方案，可以拿排队和叫号机来理解</p>\n<ul>\n<li>排队：在排队的时候，你除了等之外什么都干不了</li>\n<li>叫号机：你要做的是先取号码，等轮到你的时候，系统会通知你，这中间，你可以做任何你想做的事儿</li>\n</ul>\n<p>Node.js 其实就是帮我们构建类似的机制。我们在写代码的时候，实际上就是取号的过程，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需进程/线程切换上下文的成本，非常高效，但它在执行具体任务的时候是多线程的。</p>\n<p>Node.js 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”，毫无疑问，它确实做到了。这种做法将并发编程模型简化了，Event Loop和具体线程池等细节被 Node.js 封装了，继而将异步调用 Api 写法暴露给开发者。真是福祸相依，一方面简化了并发编程，另一方面在写法上埋下了祸根，这种做法的好处是能让更多人轻而易举的写出高性能的程序！</p>\n<p>在Node.js Bindings层做的事儿就是将 Chrome V8 等暴露的 <code>C/C++</code> 接口转成JavaScript Api，并且结合这些 Api 编写了 Node.js 标准库，所有这些 Api 统称为 Node.js SDK，后面模块章节会有更详细的讨论。</p>\n<p>微软在2016年宣布在MIT许可协议下开放 Chakra 引擎，并以 <code>ChakraCore</code> 为名在 Github 上开放了源代码，<code>ChakraCore</code> 是一个完整的 JavaScript 虚拟机，它拥有着和 <code>Chakra</code> 几乎相同的功能与特性。微软向 Node.js 主分支提交代码合并请求，让 Node.js 用上 <code>ChakraCore</code>引擎，即 <a href=\"https://github.com/nodejs/node-chakracore\">nodejs/node-chakracore</a> 项目。实际上微软是通过创建名为 <code>V8 shim</code> 的库的赋予了 <code>ChakraCore</code> 处理谷歌 Chrome V8 引擎指令的能力，其原理示意图如下</p>\n<p><img src=\"//static.cnodejs.org/FmJWcazPP4smFeEzBnfnEJuW36ts\" alt=\"15018598977763.jpg\"></p>\n<p>目前，Node.js 同时支持这2种 JavaScript 引擎，二者性能和特性上各有千秋，<code>ChakraCore</code> 在特性上感觉更潮一些，曾经是第一个支持 <code>Async函数</code> 的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主， <code>ChakraCore</code> 版本需要单独安装，大家了解一下就好。</p>\n<h2>Part 1前言：学习 Node.js 的三个境界</h2>\n<p>我总结的编程3种境界</p>\n<ul>\n<li>打日志：console.log</li>\n<li>断点调试：断点调试：node debugger 或node inspector 或vscode</li>\n<li>测试驱动开发（tdd | bdd）</li>\n</ul>\n<p>大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈</p>\n<h2>Part 2准备：如何学习Node.js</h2>\n<p>Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。</p>\n<p>它很简单，异步是解决并发的最佳实践。本节主要讲如何学习Node.js，是本次Live非常核心的内容，大家要注意听。</p>\n<h3>基础学习</h3>\n<p>1）js语法必须会</p>\n<ol>\n<li>js基本语法，都是c语系的，有其他语言背景学习起来相对更简单</li>\n<li>常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等</li>\n<li>面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。</li>\n</ol>\n<p>犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。</p>\n<p>2）个人学习和技术选型都要循序渐进</p>\n<ol>\n<li>先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单</li>\n<li>然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。</li>\n<li>等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。</li>\n</ol>\n<p>可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。</p>\n<p>团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。</p>\n<p>3）各种高级的JavaScript友好语言</p>\n<p>JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。</p>\n<p>CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。</p>\n<p>显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。</p>\n<ul>\n<li>1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到</li>\n<li>2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去</li>\n<li>3）开源，未来很好</li>\n<li>4）组合拳：TypeScript + VSCode = 神器</li>\n</ul>\n<p>当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。</p>\n<p>4）再论面向对象</p>\n<p>面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。</p>\n<ul>\n<li>基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不好是很好用。可以不用，但不可以不会。</li>\n<li>自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。</li>\n<li>js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超级，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。</li>\n</ul>\n<p>对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。</p>\n<p>我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。</p>\n<h3>安装Node.js环境</h3>\n<p>3m安装法</p>\n<ul>\n<li>nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn），nvs对window支持很好】</li>\n<li>nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】</li>\n<li>npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】</li>\n</ul>\n<h4>nvm</h4>\n<p>node版本发布非常快，而且多版本共存可能性较大，推荐使用nvm来安装node</p>\n<pre class=\"prettyprint language-shell\"><code>$ curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.6&#x2F;install.sh | bash\n\n$ echo &#x27;export NVM_DIR=&quot;$HOME&#x2F;.nvm&quot;&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ echo &#x27;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ source ~&#x2F;.zshrc\n\n$ nvm install 0.10\n$ nvm install 4\n$ nvm install 6\n$ nvm install 8\n</code></pre><h4>nrm</h4>\n<p><a href=\"https://registry.npmjs.com\">https://registry.npmjs.com</a> 是node官方的源（registry），服务器在国外，下载速度较慢，推荐安装nrm来切换源，国内的cnpm和taobao的源都非常快，当然，如果你想自建源也是支持的。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global nrm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org\n$ nrm use cnpm\n</code></pre><h4>npm</h4>\n<p>nrm切换完源之后，你安装npm模块的速度会更快。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global yarn\n</code></pre><p>npm基本命令</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>简写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install xxx</td>\n<td>安装xxx模块，但不记录到package.json里</td>\n<td>npm i xxx</td>\n</tr>\n<tr>\n<td>npm install --save xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dependency，是产品环境必须依赖的模块</td>\n<td>npm i -s xxx</td>\n</tr>\n<tr>\n<td>npm install --save-de xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dev-dependency，是开发环境必须依赖的模块，比如测试类的（mocha、chai、sinon、zombie、supertest等）都在</td>\n<td>npm i -D xxx</td>\n</tr>\n<tr>\n<td>npm install --global xxx</td>\n<td>全局安装xxx模块，但不记录到package.json里，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>\n<td>npm i -g xxx</td>\n</tr>\n</tbody>\n</table>\n<h3>常用软件</h3>\n<ul>\n<li>1）oh my zsh是我最习惯的shell，终端下非常好用</li>\n</ul>\n<p>配合iterm2分屏 + spectacle全屏，几乎无敌</p>\n<ul>\n<li>2）brew是mac装软件非常好的方式，和apt-get、rpm等都非常类似</li>\n</ul>\n<p>安装4个必备软件</p>\n<ul>\n<li>\n<p>brew install git 最流行的SCM源码版本控制软件</p>\n</li>\n<li>\n<p>brew install wget 下载、扒站神器</p>\n</li>\n<li>\n<p>brew install ack  搜索代码神器</p>\n</li>\n<li>\n<p>brew install autojump 终端下多目录跳转神器</p>\n</li>\n<li>\n<p>3）vim</p>\n</li>\n</ul>\n<p>我虽然不算vim党，但也深爱着。janus是一个非常好用的vim集成开发环境。比如ctrl-p、nerdtree等插件都集成了，对我这种懒人足够了。</p>\n<h3>IDE和编辑器</h3>\n<p>关于Node.js的IDE和编辑器有很多选择，对比如下</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>是否收费</th>\n<th>断点调试</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Webstorm</td>\n<td>收费</td>\n<td>支持</td>\n<td>是IDE，在代码提示、重构等方面功能非常强大，支持的各种语言、框架、模板也非常多，支持断点调试，好处是特别智能，缺点也是特别智能</td>\n</tr>\n<tr>\n<td>Sublime/TextMate</td>\n<td>收费</td>\n<td>不支持</td>\n<td>编辑器里非常好用的，textmate主要针对mac用户，sublime是跨平台的，相信很多前端开发都熟悉</td>\n</tr>\n<tr>\n<td>Vim/Emace</td>\n<td>免费</td>\n<td>不支持</td>\n<td>命令行下的编辑器，非常强大，难度也稍大，但更为酷炫，而且对于服务器部署开发来说是值得一学的</td>\n</tr>\n<tr>\n<td>VSCode/Atom</td>\n<td>免费</td>\n<td>支持</td>\n<td>Atom比较早，功能强大，缺点稍卡顿，VSCode是微软出的，速度快，对于Node.js 调试，重构，代码提示等方面支持都非常好</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>是一个运行于 Mac、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。它功能强大，便于调试，加上它本身也是基于 Node.js 模块 <code>electron</code> 构建的，尤其要推荐大家使用。</p>\n<p>Visual Studio Code（以下简称vsc）</p>\n<ul>\n<li>vsc是一个比较潮比较新的编辑器（跨平台Mac OS X、Windows和 Linux ）</li>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>值得一学，我推荐VSCode编辑器！</p>\n<p>更多调试方法，参见https://github.com/i5ting/node-debug-tutorial</p>\n<h3>Node.js应用场景</h3>\n<p>《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！</p>\n<p>Node.js 使用场景主要分为4大类</p>\n<p><img src=\"//static.cnodejs.org/FlXC-FcqbkX4B9ToqUVEy1m-H9Vl\" alt=\"屏幕快照 2017-05-17 07.25.05.png\"></p>\n<ul>\n<li>1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 <code>nw.js/electron</code> 、移动端 <code>cordova</code>、HTML5、<code>react-native</code>、<code>weex</code>，硬件 <code>ruff.io</code> 等</li>\n<li>2）Web应用开发：网站、Api、RPC服务等</li>\n<li>3）前端：三大框架 React \\ <code>Vue</code> \\ <code>Angular</code> 辅助开发，以及工程化演进过程（使用<code>Gulp</code> /Webpack 构建 Web 开发工具）</li>\n<li>4）工具：<code>npm</code>上各种工具模块，包括各种前端预编译、构建工具 <code>Grunt</code> / <code>Gulp</code>、脚手架，命令行工具，各种奇技淫巧等</li>\n</ul>\n<p>下面列出具体的 Node.js 的使用场景，以模块维度划分</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n<th>相关模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网站</td>\n<td>类似于 <code>cnodejs.org</code> 这样传统的网站</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>Api</td>\n<td>同时提供给移动端，PC，<code>H5</code> 等前端使用的 <code>HTTP Api</code> 接口</td>\n<td><code>Restify</code> / <code>HApi</code></td>\n</tr>\n<tr>\n<td>Api代理</td>\n<td>为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>IM即时聊天</td>\n<td>实时应用，很多是基于 <code>WebSocket</code>协议的</td>\n<td><code>Socket.io</code> / <code>sockjs</code></td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>提供类似于 <code>nginx</code> 反向代理功能，但对前端更友好</td>\n<td><code>anyproxy</code> / <code>node-http-proxy</code> / <code>hiproxy</code></td>\n</tr>\n<tr>\n<td>前端构建工具</td>\n<td>辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率</td>\n<td><code>Grunt</code> / <code>Gulp</code> / <code>Bower</code> / Webpack / <code>Fis3</code> / <code>YKit</code></td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集</td>\n<td><code>Cordova</code> / <code>Shell.js</code></td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>有实现，但估计不太会有人用</td>\n<td><code>NodeOS</code></td>\n</tr>\n<tr>\n<td>跨平台打包工具</td>\n<td>使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的</td>\n<td>PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework</td>\n</tr>\n<tr>\n<td>P2P</td>\n<td>区块链开发、BT客户端</td>\n<td><code>webtorrent</code> / <code>ipfs</code></td>\n</tr>\n<tr>\n<td>编辑器</td>\n<td><code>Atom</code> 和 <code>VSCode</code> 都是基于 <code>electron</code> 模块的</td>\n<td><code>electron</code></td>\n</tr>\n<tr>\n<td>物联网与硬件</td>\n<td>ruff.io和很多硬件都支持node sdk</td>\n<td><code>ruff</code></td>\n</tr>\n</tbody>\n</table>\n<p>Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景氛围7个部分。</p>\n<p>1）初衷，server端，不想成了前端开发的基础设施\n2）命令行辅助工具，甚至可以是运维\n3）移动端：cordova，pc端：nw.js和electron\n4）组件化，构建，代理\n5）架构，前后端分离、api proxy\n6）性能优化、反爬虫与爬虫</p>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>场景</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的，在后面的http章节里，有单独的讲解。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>爬虫</td>\n<td>有大量的爬虫模块，比如node-crawler等，写起来比python要简单一些，尤其搭配jsdom（node版本的jQuery）类库的，对前端来说尤其友好</td>\n</tr>\n<tr>\n<td>3</td>\n<td>命令行工具</td>\n<td>所有辅助开发，运维，提高效率等等可以用cli做的，使用node来开发都非常合适，是编写命令行工具最简单的方式，java8以后也参考了node的命令行实现</td>\n</tr>\n<tr>\n<td>4</td>\n<td>微服务与RPC</td>\n<td>node里有各种rpc支持，比如node编写的dnode，seneca，也有跨语言支持的grpc，足够应用了</td>\n</tr>\n<tr>\n<td>5</td>\n<td>微信公众号开发</td>\n<td>相关sdk，框架非常多，是快速开发的利器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>前端流行SSR &amp;&amp; PWA</td>\n<td>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</td>\n</tr>\n</tbody>\n</table>\n<p>可以说目前大家能够看到的、用到的软件都有 Node.js 身影，当下最流行的软件写法也大都是基于 Node.js 的，比如 PC 客户端 <a href=\"https://github.com/luin/medis\">luin/medis</a> 采用 <code>electron</code> 打包，写法采用 React + Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js 的应用场景会更加的广泛，更多参见 <a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Node核心：异步流程控制</h3>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<h4>1) 异步流程控制学习重点</h4>\n<p>我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。</p>\n<p><img src=\"//static.cnodejs.org/FowNmdNw00ghB3PxKtMz9ajo2i5c\" alt=\"Screen Shot 2017-04-05 at 08.43.08.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p>其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。</p>\n<p><img src=\"//static.cnodejs.org/Flepwa2gOwCimQX5JbOdL5bK74s1\" alt=\"Screen Shot 2017-04-05 at 08.43.34.png\"></p>\n<p>结论</p>\n<ol>\n<li>Node.js SDK里callback写法必须会的。</li>\n<li>Node.js学习重点: Async函数与Promise\n<ol>\n<li>中流砥柱：Promise</li>\n<li>终极解决方案：Async/Await</li>\n</ol>\n</li>\n</ol>\n<p>所以下面我们会分个小部分进行讲解。</p>\n<h4>2）Api写法：Error-first Callback 和 EventEmitter</h4>\n<p>a）Error-first Callback\n定义错误优先的回调写法只需要注意2条规则即可：</p>\n<ul>\n<li>回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。</li>\n<li>回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。</li>\n</ul>\n<p>下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式：</p>\n<pre class=\"prettyprint language-js\"><code>function(err, res) {\n  &#x2F;&#x2F; process the error and result\n}\n</code></pre><p>这里的 <code>callback</code> 指的是带有2个参数的函数：&quot;err&quot;和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。</p>\n<p>b）EventEmitter</p>\n<p>事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过<code>EventEmitter</code>属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的 <code>on</code> 方法监听到。</p>\n<p>在node 6之后，可以直接使用<code>require('events')</code>类</p>\n<pre class=\"prettyprint language-js\"><code>var EventEmitter = require(&#x27;events&#x27;)\nvar util = require(&#x27;util&#x27;)\n\nvar MyEmitter = function () {\n \n}\n\nutil.inherits(MyEmitter, EventEmitter)\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on(&#x27;event&#x27;, (a, b) =&gt; {\n  console.log(a, b, this);\n    &#x2F;&#x2F; Prints: a b {}\n});\n\nmyEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);\n</code></pre><p>和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。</p>\n<p>c）如何更好的查Node.js文档</p>\n<p>API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。</p>\n<p>Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。</p>\n<p>笔者推荐使用 <a href=\"https://kapeli.com/dash\">Dash</a> 或 <a href=\"https://zealdocs.org/\">Zeal</a> 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p>\n<p><img src=\"//static.cnodejs.org/FrIj8UUZLjtGeZDA8RQeBTxff55l\" alt=\"api.png\"></p>\n<h4>3）中流砥柱：Promise</h4>\n<p>回调地狱</p>\n<p>Node.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块<a href=\"https://github.com/kriskowal/q\">q</a>文档里。</p>\n<pre class=\"prettyprint language-js\"><code>step1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                &#x2F;&#x2F; Do something with value4\n            });\n        });\n    });\n});\n</code></pre><p>这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！</p>\n<p>Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。</p>\n<p>Promise最早也是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。后来人们在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是promise对象</li>\n<li>状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<p>1)定义</p>\n<pre class=\"prettyprint language-js\"><code>var promise = new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; do a thing, possibly async, then…\n\n  if (&#x2F;* everything turned out fine *&#x2F;) {\n    resolve(&quot;Stuff worked!&quot;);\n  }\n  else {\n    reject(Error(&quot;It broke&quot;));\n  }\n});\n</code></pre><p>每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。</p>\n<p>2)调用</p>\n<pre class=\"prettyprint language-js\"><code>promise.then(function(text){\n    console.log(text)&#x2F;&#x2F; Stuff worked!\n    return Promise.reject(new Error(&#x27;我是故意的&#x27;))\n}).catch(function(err){\n    console.log(err)\n})\n</code></pre><p>它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。</p>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。</p>\n<p>Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。</p>\n<p>好处如下：</p>\n<ul>\n<li>避免Node.js内置Promise实现 问题，使用与所有版本兼容</li>\n<li>避免Node.js 4曾经出现的内存泄露问题</li>\n<li>内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供了强有力的补充</li>\n</ul>\n<p>限于时间关系，这里就不一一列举了，还是那句话，在学习Node.js过程中，对于Promise了解多深入都不过分。</p>\n<p>推荐学习资料</p>\n<ul>\n<li>Node.js最新技术栈之Promise篇  <a href=\"https://cnodejs.org/topic/560dbc826a1ed28204a1e7de\">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li>\n<li>理解 Promise 的工作原理 <a href=\"https://cnodejs.org/topic/569c8226adf526da2aeb23fd\">https://cnodejs.org/topic/569c8226adf526da2aeb23fd</a></li>\n<li>Promise 迷你书 <a href=\"http://liubin.github.io/promises-book/\">http://liubin.github.io/promises-book/</a></li>\n</ul>\n<h4>4）终极解决方案：Async/Await</h4>\n<p>Async/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。</p>\n<p>这里给出一段Koa 2应用里的一段代码</p>\n<pre class=\"prettyprint\"><code>exports.list = async (ctx, next) =&gt; {\n  try {\n    let students = await Student.getAllAsync();\n  \n    await ctx.render(&#x27;students&#x2F;index&#x27;, {\n      students : students\n    })\n  } catch (err) {\n    return ctx.api_error(err);\n  }\n};\n</code></pre><p>它做了3件事儿</p>\n<ul>\n<li>通过await Student.getAllAsync();来获取所有的students信息。</li>\n<li>通过await ctx.render渲染页面</li>\n<li>由于是同步代码，使用try/catch做的异常处理</li>\n</ul>\n<p>是不是非常简单，现在Eggjs里也都是这样同步的代码。</p>\n<p>4.1 正常写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\nasync function main(){\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n}\n\nmain();\n</code></pre><p>变态写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\n(async () =&gt; {\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n})();\n</code></pre><p>4.2 await + Promise</p>\n<pre class=\"prettyprint\"><code>const Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n    const contents = await fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n    console.log(contents);\n}\n\nmain();\n</code></pre><p>4.3 await + co + generator</p>\n<pre class=\"prettyprint\"><code>const co = require(&#x27;co&#x27;);\nconst Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n   const contents = co(function* () {\n      var result = yield fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n      return result;\n   })\n\n\tconsole.log(contents);\n}\n\nmain();\n</code></pre><p>要点</p>\n<ul>\n<li>co的返回值是promise，所以await可以直接接co。</li>\n<li>co的参数是genrator</li>\n<li>在generator里可以使用yield，而yield后面接的有5种可能，故而把这些可以yield接的方式成为yieldable，即可以yield接的。\n<ul>\n<li>Promises</li>\n<li>Thunks (functions)</li>\n<li>array (parallel execution)</li>\n<li>objects (parallel execution)</li>\n<li>Generators 和 GeneratorFunctions</li>\n</ul>\n</li>\n</ul>\n<p>由上面3中基本用法可以推出Async函数要点如下：</p>\n<ul>\n<li>Async函数语义上非常好</li>\n<li>Async不需要执行器，它本身具备执行能力，不像Generator需要co模块</li>\n<li>Async函数的异常处理采用try/catch和Promise的错误处理，非常强大</li>\n<li>Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐</li>\n<li>Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景</li>\n</ul>\n<p>综上所述</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>小结</p>\n<p>这部分共讲了4个小点，都是极其直接的必须掌握的知识点。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<p>这里再提一下关于Node.js源码阅读问题，很多人api都还没完熟练就去阅读源码，这是非常不赞成的，不带着问题去读源码是比较容易迷失在大量代码中的。效果并不好。</p>\n<p>先用明白，然后再去阅读Node.js源码，然后探寻libuv并发机制。很多人买了朴大的《深入浅出Node.js》一书，看了之后还是不太会用，不是书写的不好，而是步骤不对。</p>\n<ul>\n<li>Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了</li>\n<li>当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。</li>\n<li>实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</li>\n</ul>\n<p>我一般给大家的推荐是把Node in action读上5遍10遍，入门干活足够了。剩下的就是反复实践，多写代码和npm模块就好。</p>\n<p>目前所有的书籍几乎都有点过时了，大部分都是Node.js v0.10左右的版本的，我得新书是基于Node.js 8版本的，预计2018年3月或4月出版。别催我，真没法更快了。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后（不要催我，我也没法说），20章，800页+，定价预计在130+。</p>\n<h3>Web编程要点</h3>\n<p>一般，后端开发指的是 Web 应用开发中和视图渲染无关的部分，主要是和数据库交互为主的重业务型逻辑处理。但现在架构升级后，Node.js 承担了前后端分离重任之后，有了更多玩法。从带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，到通过 RPC 调用封装对数据库的操作，到提供前端 Api 代理和网关，服务组装等，统称为<strong>后端开发</strong>，不再是以往只有和数据库打交道的部分才算后端。这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对 Node.js 来说，一直没有在后端取得其合理的占有率，原因是多方面的，暂列几条。</p>\n<ul>\n<li>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</li>\n<li>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</li>\n<li>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</li>\n<li>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</li>\n</ul>\n<p>尽管如此，Node.js 还是尽人皆知，卷入各种是非风口，也算是在大前端浪潮中大红大紫。原因它的定位非常明确，补足以 JavaScript 为核心的全栈体系中服务器部分。开发也是人，能够同时掌握并精通多门语言的人毕竟不多，而且程序员的美德是“懒”，能使用 JavaScript 一门语言完成所有事儿，为什么要学更多呢？</p>\n<p>对于 Web 应用大致分2种，带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，我们先看一下 Node.js Web 应用开发框架的演进时间线大致如下：</p>\n<ul>\n<li>2010年 TJ Holowaychuk 写的 Express</li>\n<li>2011年 Derby.js 开始开发，8月5日，WalmartLabs 的一位成员 Eran Hammer 提交了 Hapi 的第一次git记录。Hapi 原本是 Postmile 的一部分，并且最开始是基于 Express 构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于 Rest api 的 Restify 发布1.0版本，同构的 Meteor 开始投入开发，最像Rails 的 Sails 也开始了开发</li>\n<li>2013年 TJ Holowaychuk 开始玩 es6 generator，编写 <code>co</code> 这个 Generator 执行器，并开始了Koa 项目。2013 年下半年李成银开始 ThinkJS，参考 ThinkPHP</li>\n<li>2014年4月9日，Express 发布4.0，进入4.x时代持续到今天，MEAN.js 开始随着 MEAN 架构的提出开始开发，意图大一统，另外 Total.js 开始起步，最像PHP里 Laravel 或 Python 里的 Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架，代表着 Node.js 的成熟，开始从其他语言里的成熟框架借鉴</li>\n<li>2015年8月22日，下一代 Web 框架 Koa 发布1.0，可以在Node.js v0.12下面，通过<code>co</code> 和 generator实现同步逻辑，那时候 <code>co</code> 还是基于 <code>thunkfy</code> 的，在2015年10月30日，ThinkJS发布了首个基于 Es2015+ 特性开发的 v2.0 版本</li>\n<li>2016 年 09 月，蚂蚁金服的 Eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架 Koa 发布v2.0正式版</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>Tips：个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>Node.js 本来就为了做后端而设计的，这里我们再看看利益问题。Node.js 向后端延伸，必然会触动后端开发的利益。那么 Proxy 层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是 Node.js 能不能做这部分呢？答案是能的，这个是和 Java、PHP 类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以 Java、PHP 等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于 Node.js ，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用 Node.js 开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以 Node.js 在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对 Node.js 的误解。</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于 <code>MongoDB</code>、<code>MySQL</code>、<code>Redis</code> 等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题是个伪命题，所有框架面临的都是一样的。</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了，本书后面有大量篇幅讲如何使用 Koa 框架来构建Api服务。</p>\n<p>Web编程核心</p>\n<ul>\n<li>异步流程控制（前面讲过了）</li>\n<li>基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。</li>\n<li>数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事物，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。</li>\n<li>模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的。</li>\n</ul>\n<h3>迷茫时学习Node.js最好的方法</h3>\n<p>Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。现在早已经超过60万个模块了。</p>\n<p>这里就不一一举例了，给出一个<strong>迷茫时学习Node.js最好的方法</strong>吧！</p>\n<p>某天，我在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>推荐一个repo即 <a href=\"https://github.com/parro-it/awesome-micro-npm-packages\">https://github.com/parro-it/awesome-micro-npm-packages</a> 小型库集合，一天看十个不是梦！</p>\n<p>更多讨论 <a href=\"https://zhuanlan.zhihu.com/p/29625882\">https://zhuanlan.zhihu.com/p/29625882</a></p>\n<h3>非科班出身如何Node.js</h3>\n<p>有朋友提问</p>\n<pre class=\"prettyprint\"><code>狼叔，关注你和cnode很久了，最近有点迷茫，想请你指点下。\n我的情况是这样的，非科班出身，从事前端工作4年，公司使用的技术栈是vue2、vue-router、vuex、webpack，目前的能力处理工作还是比较轻松，但是也很明确自己有很多不足，只是对于如何提升比较迷茫。\n不足：\n1、非科班出身，计算机基础薄弱\n2、对当前使用的技术了解不够深入，很多东西只停留在会用的层面\n3、对服务端了解较少，想学node，却不知道如何系统的学习\n</code></pre><p>解答困惑：</p>\n<p>1、计算机基础薄弱该如何完善自己的知识体系？</p>\n<p>答:追逐长尾，所见所闻不懂的都去学就好啦。我是这样过来的，头几年每天14个小时+，很累，不过效果还可以。os，算法，数据结构，设计模式，编译原理，基本也就这些重点。做到每天都有进步就好，别贪多求快。数学和英文当然也是越狠越好的！</p>\n<p>2、如何在技术上做更深入的探索？</p>\n<p>答:技术人只关注技术，想法创意通常比较少。最简单的办法就是抓自己的痒，比我大学时和朋友们翻译过grails文档，所以对翻译有情节。为了翻译，我用node写了无数工具尝试，反复对比各种翻译工具，理解它们背后的设计。包括markdown里嵌html标签标识中英文，然后gulp编译成独立文档。甚至一度想上线卖服务。这种折腾真的很爽，甚至耽误了不少翻译。有时要警惕长尾，不要忘了自己的初衷</p>\n<p>3、如何系统的学习node？</p>\n<p>答:阶段</p>\n<p>1/要会用，能完成工作任务\n2/写点提高效率的工具\n3/参与开源项目，甚至是node源码</p>\n<p>应对方法</p>\n<p>1/《node in action》看五遍，然后就去写吧，别管代码质量如何，能写敢写\n2/多用些模块，理解它们，如果有机会就自己写一下，万一有很多人用你，我小弟写过一个地区选择加载的json数据，star数不少呢\n3/给别人贡献代码，要去学别人的习惯，网上有git标准工作流和提pr方法，你要做的是精研该模块代码，关注issue，其他就是等机会。另外朴灵的深入浅出多读几遍，试着读node源码，你的理解会更好。推荐看看我写的《通过开源项目去学习》<a href=\"https://github.com/i5ting/Study-For-StuQ\">https://github.com/i5ting/Study-For-StuQ</a>\n4/跳出node范围，重新审视node的应用场景，对未来你的技术选项和决策大有裨益</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n</ul>\n<p>答：如果有机会就直接上Web应用，如果没有机会就从前端构建，工具等方面开始做，慢慢引入更潮更酷的前端技术，自然就把Node引入进来了。不要急。</p>\n<ul>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n</ul>\n<p>答：初学者推荐Express，如果有一定经验，推荐Koa。当然真正项目里还是推荐Eggjs和Thinkjs这样的框架。</p>\n<ul>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>答：\n1）Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了\n2）当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。\n3)实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</p>\n<p>如果你不着急，也可以等我的那本《更了不起的Node.js》，时间待定。</p>\n<h2>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</h2>\n<p>有朋友问现在Android开发和web前端开发哪个前景更好？我的回答是明显是前端更好，看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。</p>\n<p>Web开发对移动端的冲击非常大。当然现在Web技术也开发PC client了，比如vscode是通过electron打包的，效果还是相当不错的。</p>\n<p>前端可以说是最近几年开发里最火的部分，原因很多，最主要是开发方式的变更，以今时今日的眼光来看，称之为现代Web开发是不为过的。</p>\n<p>先给出现代Web开发的概览图</p>\n<p><img src=\"//static.cnodejs.org/Fq7XArZKEXlzHEwBiR35IxHs4nOg\" alt=\"15117552681353.jpg\"></p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，这也是我那本书书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<p>全栈核心</p>\n<ul>\n<li>后端不会的 UI（界面相关）</li>\n<li>前端不会的 DB（业务相关）</li>\n</ul>\n<p>只要打通这2个要点，其他就比较容易了。最怕的是哪样都接触点，然后就号称自己是全栈，建议大家不要这样做，这就好比在简历里写精通一样，基本上都会被问到尴尬。全栈是一种信仰，不是拿来吹牛逼的，而可以解决更多问题，让自己的知识体系不留空白，享受自我实现的极致快乐。</p>\n<h3>我的全栈之路</h3>\n<p>想问一下狼叔最近的业务一直都是简单的用express搭一个后端服务，没有其他更加深入node的业务了，这种时候应该如何自己给自己创应用场景呢</p>\n<blockquote>\n<p>没有目标就向钱看，有目标就向前看</p>\n</blockquote>\n<ul>\n<li>从 java 开始，蹭课，背着机箱到深圳，3个月胖20斤</li>\n<li>坚持翻译英文文档，看 《Thinking in Java》</li>\n<li>毕业后开始 bi，整理 bi 文档</li>\n<li>学长明林清，传授 jQuery，愿意学，别人就更愿意分析</li>\n<li>接手《内蒙广电数据分析与科学决策系统》，打通前、后端</li>\n<li>广东联通，自己造轮子，写 jQuery 插件，DRY</li>\n<li>做云计算，学习 AIX，写有《凌云志》</li>\n<li>分手、离职，去做 iOS，从 cordova 开始搞 H5，研究各种移动端框架，自己写框架，转原生</li>\n<li>面试也是学习的利器，轻松进新浪</li>\n<li>总结了大量 iOS 经验，想写书，结果写了一堆写书的工具</li>\n</ul>\n<blockquote>\n<p>既然无法逃避，就热爱它，最后变成兴趣</p>\n</blockquote>\n<ul>\n<li>去网秦做技术总监，做首席，管架构，带人，写开源项目</li>\n<li>创业，当 CTO，结婚，做公众号运营，写书，最苦的时候没钱吃饭，又不能找媳妇要，只能在 StuQ 上讲点课</li>\n<li>加入去哪儿网，任职前端架构师</li>\n<li>加入阿里巴巴，前端技术专家</li>\n</ul>\n<blockquote>\n<p>人生不只有代码，但它能让我快乐，终生受益</p>\n</blockquote>\n<p>也曾懵懂，也曾迷茫，但我这人比较傻，一直信奉：“一次只做1件事儿，尽力做到极致”，短时间看这是比较傻的，但一旦你坚持下去，你就会发现技术其实是门手艺，厚积薄发。</p>\n<p>我没办法说自己最擅长什么，但在什么场景下用什么技术是我擅长的。或者说，应变是我最大的本事。很多框架，新技术我都没见过，用过，但花一点点过一下，就能拿已有的知识快速的理解它，这其实是长期学习的好处。</p>\n<p>现在越来越忙，写代码的时间越来越少，技术又越发展越快，我能做好的就是每日精进，仗着这点已有的知识储备跟年轻人比赛。我不觉得累，相反我很享受这种感觉，没有被时代淘汰，是一件多么幸福的事儿。</p>\n<h3>从后端转</h3>\n<p>做后端的人</p>\n<ul>\n<li>对数据库是比较熟悉，无论 mongodb，还是 mysql、postgres</li>\n<li>对前端理解比较弱，会基本的 html，css，模板引擎等比较熟悉</li>\n</ul>\n<blockquote>\n<p>4阶段循序渐进，build 与工具齐飞</p>\n</blockquote>\n<p>前端开发4阶段，我的感觉是按照顺序，循序渐进就好。</p>\n<h3>从前端转</h3>\n<p>从前端往后端转，api 接口非常容易学会，像 express、koa 这类框架大部分人一周就能学会，最难的是对 db、er 模型的理解，说直白点，还是业务需求落地的理解</p>\n<p>我们来想想一般的前端有什么技能？</p>\n<ul>\n<li>html</li>\n<li>css（兼容浏览器）</li>\n<li>js 会点（可能更多的是会点 jquery）</li>\n<li>ps 切图</li>\n<li>firebug 和 chrome debuger 会的人都不太多</li>\n<li>用过几个框架，大部分人是仅仅会用</li>\n<li>英语一般</li>\n<li>svn/git 会一点</li>\n</ul>\n<p>那么他们如果想在前端领域做的更深有哪些难点呢？</p>\n<ul>\n<li>基础：oo，dp，命令，shell，构建等</li>\n<li>编程思想上的理解（mvc、ioc，规约等）</li>\n<li>区分概念</li>\n<li>外围验收，如 H5 和 hybird 等</li>\n<li>追赶趋势，如何学习新东西</li>\n</ul>\n<p>以上皆是痛点，所以比较好的办法应该是这样的。</p>\n<ul>\n<li>玩转 npm、gulp 这样的前端工具类（此时还是前端）</li>\n<li>使用 node 做前后端分离（此时还是前端）</li>\n<li>express、koa 这类框架</li>\n<li>jade、ejs 等模板引擎</li>\n<li>nginx</li>\n<li>玩转【后端】异步流程处理（promise/es6的(generator|yield)/es7(async|await)）</li>\n<li>玩转【后端】mongodb、mysql 对应的 Node 模块</li>\n</ul>\n<p>从我们的经验看，这样是比较靠谱的。先做最简单前后端分离，里面没有任何和db相关，前端可以非常容易的学会，基本2周就已经非常熟练了。一般半年后，让他们接触【异步流程处理】和【数据库】相关内容，学习后端代码，就可以全栈了。</p>\n<h3>从移动端转</h3>\n<p>看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。狼叔一直固执的以为未来是h5的。</p>\n<p>现在的 Native 开发是姥姥不疼舅舅不爱，非常尴尬，很明显连培训出的人就业不要工资混经验就很明显了。另外领导们也都在惦记，能不能用 H5 写？这还算是保守的，如果直接激进的就直接上 RN 了，那么 Native开发的程序员就变了</p>\n<blockquote>\n<p>一个写插件的程序员…招谁惹谁了。。。。</p>\n</blockquote>\n<p>要么忍，要么转，没办法，认命吧，温水里舒服了几年，也该学点东西了</p>\n<ul>\n<li>hybrid 或组件化开发，你总要会一样</li>\n<li>无论哪种，你都离前端很近，因为 H5 或组件化都是从前端走出来的</li>\n<li>组件化在前端领域先行，无论借鉴还是学习都不可避免</li>\n<li>如果没时间就直接上组件化，如果有时间就好好学学前端完整体系，最终也还是要学组件化</li>\n</ul>\n<p>原生开发就是 iOS 用 OC/Swift,Android 用 java 或 scala 等，就算偶尔嵌入 webview，能玩js的机会也非常好少</p>\n<p>所以移动端转全栈的方法，最好是从 cordova（以前叫 phonegap）开始做 hybrid 开发。</p>\n<ul>\n<li>只要关注 www 目录里的 H5 即可，比较简单</li>\n<li>如果 H5 不足以完成的情况下，可以编写 cordova 插件，即通过插件让 js 调用原生 sdk 里功能</li>\n<li>cordova 的 cli 可以通过 npm 安装，学习 npm 的好方法</li>\n<li>学习 gulp 构建工具</li>\n</ul>\n<p>只要入了 H5 的坑，其实就非常好办了。</p>\n<ul>\n<li>然后 h5、zeptojs、iscroll、fastclick 等</li>\n<li>然后微信常用的，如 weui、vux（vue+weui）、jmui（react+weui）</li>\n<li>然后可以玩点框架，比如 jquery mobile，sencha touch</li>\n<li>然后可以玩点高级货，ionicframework（基于 angularjs、cordova）</li>\n<li>然后前端4阶段，依次打怪升级</li>\n<li>然后 node</li>\n</ul>\n<p>这个基本上是我走的路，从2010年写iOS、做phonegap（当时是0.9.3）、一路走到现在的总结吧！</p>\n<p>以前技术发展还不是那么明显，写 Java 的时候 <code>Apache</code> 的开源用的比较多，那时开源的代码托管<code>sourceforge</code>，<code>google code</code> 也都凑合用，自从 <code>Git</code> 和 <code>GitHub</code> 出现时候，代码社交兴起，极大的促进了开源的活跃，使得大量明星项目脱引而出。这是好事，如果没有开源，中国的软件水平真是要落后好多年。那么问题也来了，如何能够在技术快速发展的今天，个人成长也能更好呢？</p>\n<p>学习的3种层次，跟人学最快，其次是跟书（或者博客）学，最差的是自悟。但是牛人不能遇到，遇到了也未必有精力教你，书本或者博客，别人有，但不一定写出来，就算是写了，可能只是点到为止。至于自悟，如果没有深厚的积累的，还是有相当大难度的。</p>\n<p>对于开发来说代码是一切基础，在掌握了一定计算机基础后，其差别就在于代码质量和眼界。编程没有捷径，能够做到每日精进就是极好的。现在开源代码非常多，要能够从中获取自己所需的知识，也是一种本领！如果能够坚持着每日精进，根本不需要向其他人学习的。</p>\n<p><img src=\"//static.cnodejs.org/FvXJwylBhEv33TowEJYMfX-CULZC\" alt=\"15011322589471.jpg\"></p>\n<p>大家可以在 Github 随便打开一个前端项目，里面有一半以上都是 Node.js 相关信息，各种包管理、测试、ci、辅助模块，如果大家对这些基础信息掌握的非常好，那么学习一个新的框架，你要比别人快好多，最重要的是学了一次，到处使用。</p>\n<p>很多人问我怎么才能成为一个 Node.js 大神？我的回答是“在cnode论坛上坚持写文章和开源项目2年，足矣，轻松进阿里腾讯，不用你找他们，他们自会找你的”。</p>\n<blockquote>\n<p>从今天起，开始重视开源项目，重视 node，做到每日精进</p>\n</blockquote>\n<h2>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</h2>\n<h3>招人标准</h3>\n<p>先说下我的招人标准，做技术总监时上指下派只要看好技术能力和态度即可，做CTO时要考虑团队文化，人品和能否在公司长留，所以不同的人面试要看的点是不一样的，我曾面过很多Node.js程序员，也见过很多面试题，汇总一下，大致有以下9个点：</p>\n<ol>\n<li>基本的Node.js几个特性，比如事件驱动、非阻塞I/O、Stream等</li>\n<li>异步流程控制相关，Promise是必问的</li>\n<li>掌握1种以上Web框架，比如Express、Koa、Thinkjs、Restfy、Hapi等，会问遇到过哪些问题、以及前端优化等常识</li>\n<li>数据库相关，尤其是SQL、缓存、Mongodb等</li>\n<li>对于常见Node.js模块、工具的使用，观察一个人是否爱学习、折腾</li>\n<li>是否熟悉linux，是否独立部署过服务器，有+分</li>\n<li>js语法和es6、es7，延伸CoffeeScript、TypeScript等，看看你是否关注新技术，有+分</li>\n<li>对前端是否了解，有+分</li>\n<li>是否参与过或写过开源项目，技术博客、有+分</li>\n</ol>\n<p>补充一句:只看技能没人品的人，千万别招，白脸狼</p>\n<p>主动执行，辅助团队\n掌握一门后端语言；熟悉用户体验相关知识；了解软件工程。\n精通浏览器工作原理，熟悉HTTP协议，熟悉设计模式。\n掌握改善无障碍访问的方法；掌握数据采集分析能力；熟悉可维护性问题。\n通过开发、使用、推广效率工具让自己与团队的效率得到提高；\n提炼可复用组件，为类库贡献高质量代码.\n积极完善知识库；\n跨团队分享技术和专业相关知识。\n辅导新人技能成长；\n协助主管做招聘和团队管理工作。</p>\n<h3>大家是选大公司还是小公司？</h3>\n<p>我再知乎上回复的《在跳槽后的第三个月，收到世界500强的offer，我该怎么办？》</p>\n<p>1）互联网公司优先，流量大，人才多，机会也多，流程规范一些</p>\n<p>2）今天的世界500强不比从前了，普华永道应该是四大之一，不知道信息化怎么样，你只要和你现在的公司对比就好了。</p>\n<p>3）问问自己想要什么，钱，经历，还是时间</p>\n<p>如果你很年轻，现在很安逸，我建议你换。如果不是很想动，那就学会所有能接触到的知识再换。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>大公司的做事方式</p>\n<ul>\n<li>按照规矩做事，不要碰红线</li>\n<li>工时一般压的都不会太紧，都是可以商量的，但态度一定要好</li>\n<li>闲的时候自己学点东西，上班要学习相关，下班学不相干的。别犯傻。</li>\n<li>多创造点额外价值，让你的领导更喜欢你</li>\n<li>理解能力要强，不要让你的领导说二遍。</li>\n</ul>\n<p>小公司</p>\n<ul>\n<li>简单粗暴，快速出东西，领导最关心的是进度</li>\n<li>执行力要强，遇佛杀佛，有鬼杀鬼</li>\n<li>代码质量其实没太多人管，但自己要注意养成好习惯</li>\n<li>没有机会自己创造机会。创造机会之前是赢得信任。</li>\n</ul>\n<p>狼叔经常说的一句：“少抱怨，多思考，未来更美好”，大部分人都喜欢积极的人，遇到问题不怕不躲不避，要相信自己能够解决，最多是时间问题。</p>\n<p>还有一句是：“没目标向钱看，有目标向前看”。历史上很多这样的例子，在2010年左右iOS开发刚起步，会拖拽弄个界面的就五位数工资，比做JAVA的几年的都要多。这世界就是这样不公平。但是你也不能不思进取，这样也是极其危险。在2016年左右，其实iOS开发就遇到了市场饱和的问题，很多培训出来的人都找不到工作，各家公司都在考虑换react-native或weex或者h5。</p>\n<p>所以，当你有机会进入一个很有前途的方向，你要努力学好，并准备好下一个阶段的应变。相反，如果当成找一个养老的地方，早晚会遇到尴尬的。比如现在很多iOS程序员被迫去学react/vue等，境遇也不太好的，更有甚者直接被开除。</p>\n<h3>优酷-高级前端开发</h3>\n<p>职位描述</p>\n<ol>\n<li>支撑企业级应用后台开发，使用 React 等前端框架搭建后台页面，实现交互需求及后端服务对接;</li>\n<li>以模块化的思想设计开发通用前端组件，并能够针对OTT,移动端进行针对性优化；</li>\n<li>在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具；</li>\n<li>在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展；</li>\n<li>关注前端前沿技术研究，通过新技术服务团队和业务；</li>\n<li>使用 Weex 技术开发产品需求。&quot;</li>\n</ol>\n<p>职位要求</p>\n<ol>\n<li>精通前端技术，包括HTML/CSS/JavaScript/Node.JS等；</li>\n<li>掌握Bootstrap，jQuery，AngularJS，React等框架，并有项目实践；</li>\n<li>熟悉前端模块化、编译和构建工具，如grunt，gulp,webpack等；</li>\n<li>至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby）,有项目实践更佳；</li>\n<li>具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索；</li>\n<li>具有较强的学习能力，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和产品，UED，后端等方向同学合作。</li>\n</ol>\n<h3>PixelLab</h3>\n<p>PixelLab是与淘宝GM Lab联合成立的专注于视频算法方向的研发部门，主要涉及视频的空间感知、轨迹跟踪、图像分割、遮挡检测以及照片级渲染等相关技术。用于实现视频内的内容植入与后期特效的研发，属于视频MR的场景，主要应用于广告植入平台的研发，方向靠谱老板人好，欢迎推荐。主要需要的岗位包括了图像算法、3D视觉算法，渲染算法，WebGL以及并行计算等几大方向，因为算法类招聘实在难，所以将JD的链接帖出来希望同事们有适合的人可以内推一下。</p>\n<p>岗位要求：</p>\n<ol>\n<li>本科及以上学历，5年以上工作开发经验；</li>\n<li>扎实的计算几何基础，熟悉常见数学工具；</li>\n<li>熟练WebGL, Canvas渲染开发，熟练Shader编写， 熟悉Three.js, OSG.js者优先;</li>\n<li>熟练运用JavaScript语言与HTML5、CSS3等技术;</li>\n<li>熟悉主流移动浏览器的技术特点，有移动端H5, WebGL项目经验者优先;</li>\n<li>有移动端WebGL开发经验者优先;</li>\n<li>学习能力强、应变能力强，优秀的沟通能力和协调能力，执行能力强，具备较强的团队合作精神。</li>\n</ol>\n<h3>蚂蚁金服</h3>\n<p>岗位要求：</p>\n<ul>\n<li>大学本科学历，2年以上开发经验，能熟练使用常见类库或框架，编写高质量的前端代码；</li>\n<li>熟悉NodeJS，有NodeJS开发经验，熟悉Express\\koa等框架；</li>\n<li>熟练掌握React、Redux及相关框架和技术，有单页面应用开发经验；</li>\n<li>精通ES6，gulp，webpack等规范和技术；</li>\n<li>善于 Web 性能优化与前端效果的实现；</li>\n<li>良好的团队合作精神和积极主动的沟通意识，具有很强的学习能力和对新技术的追求精神，乐于分享；</li>\n<li>有大型网站开发经验者优先。</li>\n</ul>\n<p>我们的前端专业建设方向</p>\n<ul>\n<li>基于ReactJS的主题可配置组件化平台</li>\n<li>基于Nodejs的UED中台业务（浏览器端web页面监控等）</li>\n<li>基于Docker的nodejs云容器平台</li>\n<li>基于Webpack的前端工程化体系建设</li>\n<li>基于eggjs的react同构框架</li>\n<li>基于G2的业务数据可视化组件库</li>\n<li>大规模图形识别/图像处理/AR/VR//语音交互等研究性领域探索</li>\n</ul>\n<h3>联系方式</h3>\n<p>目前北京，杭州，广州，上海，深圳，成都都在招聘，如果你也想跟我一起共事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>有机会和winter，勾股，玉伯，苏千，朴灵、死马、偏右，徐飞，阮一峰，天猪，裕波等大神一起工作哦。</p>\n<p>悄悄地说，其实其他公司我也可以帮推荐。</p>\n<h2>结束语</h2>\n<p>年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。</p>\n<p>狼叔说: “少抱怨，多思考，未来更美好”</p>\n<p>大部分人体会不到坚持的乐趣，不会玩，所以抱怨多。其实玩出乐趣也是一种能力，尤其是像写代码这种看似无聊的事儿。最开始可能只想赚点钱，后面变成热爱，这样才美好。只要坚持每日精进开心就好了。</p>\n<p>另外，时间也要好处处理，狼叔总会提菜根谭上的一句话:【闲时要有吃紧的心思，忙里要有偷闲的乐趣】。</p>\n<p>每个人的一生中都有很多坎，类似于瓶颈，唯有苦难和坚持才能冲破，坚持会产生自信，苦难会创造机会。一个经过苦难还有自信的人，一定会有更美好的未来。</p>\n<p>如果大家还有问题，可以去cnode社区发帖at我，也可以在Node全栈公众号提问。</p>\n<h2>Part 5答疑：回答大家的问题</h2>\n<p>答疑有点多，这里就不一一贴出来，如果是新用户和比较迷茫的Node朋友去Live里听吧。</p>\n<ul>\n<li>感谢justjavac大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址</a></li>\n</ul>\n</div>","title":"【全文】狼叔：如何正确的学习Node.js","last_reply_at":"2019-04-02T11:23:49.247Z","good":true,"top":false,"reply_count":99,"visit_count":55762,"create_at":"2018-03-22T02:35:23.073Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5ca2baa76c1de62dce466bc6","author_id":"5ca2a0806c1de62dce466b43","tab":"share","content":"<div class=\"markdown-text\"><p>看《社交网络》时，扎克伯格用博客直播黑掉隔壁宿舍的照片网站，顿时觉得太酷！当即决定开发一个玩玩。但随着使用的深入，功能逐渐扩展至大部分文字使用场景，比如我用它记录要看的书籍，美剧，电影，记录技术要点，记录网址，写购物清单，写工作列表，写博客等。我甚至用它与几个笔友聊天。\n优点是：对文档进行分类管理；打开就可以开始记录，无需登录\n缺点是：不适合贴代码；界面还不够美观</p>\n<p><a href=\"http://talkooo.com\">网站: talkooo.com</a></p>\n<p>我一个人玩太无聊了，希望能多几个人来玩玩！随手记可能对部分人有用，因为我每天都要使用到它。下面是我的使用截图:</p>\n<p><img src=\"//static.cnodejs.org/FsOhB8-btlOAgNa3XnO2sJXNLHE2\" alt=\"IMG_1009.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FhBipZmao8I2o-yglUXspesk-d5u\" alt=\"IMG_1012.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FoAEPLBf4-tmFY1rr7R4n9qzUWxu\" alt=\"IMG_1011.PNG\"></p>\n</div>","title":"用Node.js写了一个随手记的web应用","last_reply_at":"2019-04-02T10:23:50.860Z","good":false,"top":false,"reply_count":2,"visit_count":363,"create_at":"2019-04-02T01:28:07.024Z","author":{"loginname":"talkooo","avatar_url":"https://avatars2.githubusercontent.com/u/47216906?v=4&s=120"}},{"id":"5b63b25e792f59ae501bf71c","author_id":"59c12213e7d9a031127ead16","tab":"share","content":"<div class=\"markdown-text\"><h4>RPC是什么</h4>\n<p>在很久之前的单机时代，一台电脑中跑着多个进程，进程之间没有交流各干各的，就这样过了很多年。突然有一天有了新需求，A进程需要实现一个画图的功能，恰好邻居B进程已经有了这个功能，偷懒的程序员C想出了一个办法：A进程调B进程的画图功能。于是出现了<code>IPC</code>（Inter-process communication，进程间通信）。就这样程序员C愉快的去吃早餐去了！</p>\n<p>又过了几年，到了互联网时代，每个电脑都实现了互联互通。这时候雇主又有了新需求，当时还没挂的A进程需要实现使用<code>tensorflow</code>识别出笑脸 &gt;_&lt; 。说巧不巧，远在几千里的一台快速运行的电脑上已经实现了这个功能，睡眼惺忪的程序媛D接手了这个A进程后借鉴之前<code>IPC</code>的实现，把<code>IPC</code>扩展到了互联网上，这就是<code>RPC</code>(Remote Procedure Call，远程过程调用)。<code>RPC</code>其实就是一台电脑上的进程调用另外一台电脑上的进程的工具。成熟的<code>RPC</code>方案大多数会具备服务注册、服务发现、熔断降级和限流等机制。目前市面上的RPC已经有很多成熟的了，比如<code>Facebook</code>家的<code>Thrift</code>、<code>Google</code>家的<code>gRPC</code>、阿里家的<code>Dubbo</code>和蚂蚁家的<code>SOFA</code>。</p>\n<h4>接口定义语言</h4>\n<p>接口定义语言，简称<code>IDL,</code>是实现端对端之间可靠通讯的一套编码方案。这里有涉及到传输数据的序列化和反序列化，我们常用的http的请求一般用json当做序列化工具，定制<code>rpc</code>协议的时候因为要求响应迅速等特点，所以大多数会定义一套序列化协议。比如：</p>\n<p><code>Protobuf</code>：</p>\n<pre class=\"prettyprint language- protobuf\"><code>&#x2F;&#x2F; protobuf 版本\nsyntax = &quot;proto3&quot;;\n \npackage testPackage;\n \nservice testService {\n  &#x2F;&#x2F; 定义一个ping方法，请求参数集合pingRequest, 响应参数集合pingReply \n  rpc ping (pingRequest) returns (pingReply) {}\n}\n \nmessage pingRequest {\n  &#x2F;&#x2F; string 是类型，param是参数名，1是指参数在方法的第1个位置\n  string param = 1;\n}\n \nmessage pingReply {\n  string message = 1;\n  string content = 2;\n}\n</code></pre><p>讲到<code>Protobuf</code>就得讲到该库作者的另一个作品<code>Cap'n proto</code>了，号称性能是直接秒杀<code>Google Protobuf</code>，直接上官方对比：</p>\n<p><img src=\"https://capnproto.org/images/infinity-times-faster.png\" alt=\"Cap'n proto\"></p>\n<p>虽然知道很多比<code>Protobuf</code>更快的编码方案，但是快到这种地步也是厉害了，为啥这么快，Cap’n Proto的文档里面就立刻说明了，因为<code>Cap'n Proto</code>没有任何序列号和反序列化步骤，<code>Cap'n Proto</code>编码的数据格式跟在内存里面的布局是一致的，所以可以直接将编码好的structure直接字节存放到硬盘上面。贴个栗子：</p>\n<pre class=\"prettyprint language- shell\"><code>@0xdbb9ad1f14bf0b36;  # unique file ID, generated by &#96;capnp id&#96;\n\nstruct Person {\n  name @0 :Text;\n  birthdate @3 :Date;\n\n  email @1 :Text;\n  phones @2 :List(PhoneNumber);\n\n  struct PhoneNumber {\n    number @0 :Text;\n    type @1 :Type;\n\n    enum Type {\n      mobile @0;\n      home @1;\n      work @2;\n    }\n  }\n}\n\nstruct Date {\n  year @0 :Int16;\n  month @1 :UInt8;\n  day @2 :UInt8;\n}\n</code></pre><p>我们这里要定制的编码方案就是基于<code>protobuf</code>和<code>Cap'n Proto</code>结合的类似的语法。因为本人比较喜欢刀剑神域里的男主角，所以就给这个库起了个名字    —— <code>Kiritobuf</code>。</p>\n<p>首先我们定义<code>kirito</code>的语法：</p>\n<pre class=\"prettyprint language-bash\"><code># test\n\nservice testService {\n  method ping (reqMsg, resMsg)\n}\n\nstruct reqMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n\nstruct resMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n</code></pre><ul>\n<li><code>#</code> 开头的是注释</li>\n<li>保留关键字, <code>service</code>、<code>method</code>、<code>struct</code>,</li>\n<li><code>{}</code>里是一个块结构</li>\n<li><code>()</code>里有两个参数，第一个是请求的参数结构，第二个是返回值的结构</li>\n<li><code>@</code>是定义参数位置的描述符，<code>0</code>表示在首位</li>\n<li><code>=</code>号左边是参数名，右边是参数类型</li>\n</ul>\n<p>参数类型：</p>\n<ul>\n<li><strong>Boolean:</strong> <code>Bool</code></li>\n<li><strong>Integers:</strong> <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>\n<li><strong>Unsigned integers:</strong> <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code></li>\n<li><strong>Floating-point:</strong> <code>Float32</code>, <code>Float64</code></li>\n<li><strong>Blobs:</strong> <code>Text</code>, <code>Data</code></li>\n<li><strong>Lists:</strong> <code>List(T)</code></li>\n</ul>\n<p>定义好了语法和参数类型，我们先过一下生成有抽象关系代码的流程：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/kirito.jpg\" alt=\"ast\"></p>\n<p>取到<code>.kirito</code>后缀的文件，读取全部字符，通过词法分析器生成<code>token</code>，得到的<code>token</code>传入语法分析器生成<code>AST (抽象语法树)</code>。</p>\n<p>首先我们新建一个<code>kirito.js</code>文件:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27;;\n\nconst fs = require(&#x27;fs&#x27;);\nconst tokenizer = Symbol.for(&#x27;kirito#tokenizer&#x27;);\nconst parser = Symbol.for(&#x27;kirito#parser&#x27;);\nconst transformer = Symbol.for(&#x27;kirito#transformer&#x27;);\n&#x2F;&#x2F; 定义词法分析Token类型 \nconst TYPE = {\n  &#x2F;&#x2F; 保留字，service、struct、method...\n  KEYWORD: &#x27;keyword&#x27;,\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;variable&#x27;,\n  &#x2F;&#x2F; 符号，{ } ( ) ; # @ ,\n  SYMBOL: &#x27;symbol&#x27;,\n  &#x2F;&#x2F; 参数位置，数值表示0、1、2、3...\n  INDEX: &#x27;index&#x27;\n};\n&#x2F;&#x2F; 定义语法分析字段类型\nconst EXP = {\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;Identifier&#x27;,\n  &#x2F;&#x2F; 结构申明，service、struct、method\n  STRUCT_DECLARATIONL: &#x27;StructDeclaration&#x27;,\n  &#x2F;&#x2F; 变量申明，@\n  VAR_DECLARATION: &#x27;VariableDeclaration&#x27;,\n  &#x2F;&#x2F; 数据类型, Int16、UInt16、Bool、Text...\n  TYPE: &#x27;DataType&#x27;,\n};\n</code></pre><p>定义好了一些必要的字面量，接下来首先是词法分析阶段。</p>\n<h5>词法解析</h5>\n<p>我们设计词法分析得到的<code>Token</code>是这样子的：</p>\n<pre class=\"prettyprint language-shell\"><code>[ { type: &#x27;keyword&#x27;, value: &#x27;service&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;testService&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;method&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;ping&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;(&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;)&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; } ]\n</code></pre><p>词法分析步骤：</p>\n<ul>\n<li>把获取到的<code>kirito</code>代码串按照<code>\\n</code>分割组合成数组A，数组的每个元素就是一行代码</li>\n<li>遍历数组A，将每行代码逐个字符去读取</li>\n<li>在读取的过程中定义匹配规则，比如注释、保留字、变量、符号、数组等</li>\n<li>将每个匹配的字符或字符串按照对应类型添加到tokens数组中</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>[tokenizer] (input) {\n    &#x2F;&#x2F; 保留关键字\n    const KEYWORD = [&#x27;service&#x27;, &#x27;struct&#x27;, &#x27;method&#x27;];\n    &#x2F;&#x2F; 符号\n    const SYMBOL = [&#x27;{&#x27;, &#x27;}&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;@&#x27;, &#x27;;&#x27;];\n    &#x2F;&#x2F; 匹配所有空字符\n    const WHITESPACE = &#x2F;\\s&#x2F;;\n    &#x2F;&#x2F; 匹配所有a-z的字符、不限大小写\n    const LETTERS = &#x2F;^[a-z]$&#x2F;i;\n    &#x2F;&#x2F; 匹配数值\n    const NUMBER = &#x2F;\\d&#x2F;;\n    \n    &#x2F;&#x2F; 以换行符分割成数组\n    const source = input.split(&#x27;\\n&#x27;);\n    &#x2F;&#x2F; 最终生成的token数组\n    const tokens = [];\n    source.some(line =&gt; {\n      &#x2F;&#x2F; 声明一个 &#96;current&#96; 变量作为指针\n      let current = 0;\n      &#x2F;&#x2F; 是否继续当前循环、移动到下一行，用于忽略注释\n      let isContinue = false;\n      while (current &lt; line.length) {\n        let char = line[current];\n\n        &#x2F;&#x2F; 匹配任何空字符\n        if (WHITESPACE.test(char)) {\n          current++;\n          continue;\n        }\n\n        &#x2F;&#x2F; 忽略注释\n        if (char === &#x27;#&#x27;) {\n          isContinue = true;\n          break;\n        }\n\n        &#x2F;&#x2F; 匹配a-z|A-Z的字符\n        if (LETTERS.test(char)) {\n          &#x2F;&#x2F; 定义一个字符串变量，用来存储连续匹配成功的字符\n          let value = &#x27;&#x27;;\n          &#x2F;&#x2F; 匹配字符(变量&#x2F;保留字)、字符加数字(参数类型)\n          while (LETTERS.test(char) || NUMBER.test(char)) {\n            &#x2F;&#x2F; 追加字符\n            value += char;\n            &#x2F;&#x2F; 移动指针\n            char = line[++current];\n          }\n          if (KEYWORD.indexOf(value) !== -1) {\n            &#x2F;&#x2F; 匹配保留关键字\n            tokens.push({\n              type: TYPE.KEYWORD,\n              value: value\n            });\n          } else {\n            &#x2F;&#x2F; 匹配变量名、类型\n            tokens.push({\n              type: TYPE.VARIABLE,\n              value: value\n            });\n          }\n          continue;\n        }\n\n        &#x2F;&#x2F; 匹配符号 { } ( ) = @\n        if (SYMBOL.indexOf(char) !== -1) {\n          tokens.push({\n            type: TYPE.SYMBOL,\n            value: char\n          });\n          &#x2F;&#x2F; 匹配@ 参数位置符号\n          if (char === &#x27;@&#x27;) {\n            char = line[++current];\n            &#x2F;&#x2F; 匹配参数位置0-9\n            if (NUMBER.test(char)) {\n              &#x2F;&#x2F; 定义参数位置字符串，用来存储连续匹配成功的参数位置\n              let index = &#x27;&#x27;;\n              &#x2F;&#x2F; 匹配参数位置0-9\n              while (NUMBER.test(char)) {\n                &#x2F;&#x2F; 追加参数位置 &#96;1&#96;+&#96;2&#96;=&#96;12&#96;\n                index += char;\n                char = line[++current];\n              }\n              tokens.push({\n                type: TYPE.INDEX,\n                value: index\n              });\n            }\n            continue;\n          }\n          current++;\n          continue;\n        }\n        current++;\n      }\n        \n      &#x2F;&#x2F; 跳过注释\n      if (isContinue) return false;\n    });\n    return tokens;\n  }\n</code></pre><h5>语法分析</h5>\n<p>得到上面的词法分析的token后，我们就可以对该token做语法分析，我们需要最终生成的AST的格式如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;type&quot;: &quot;Program&quot;,\n  &quot;body&quot;: [\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;service&quot;,\n      &quot;value&quot;: &quot;testService&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;StructDeclaration&quot;,\n          &quot;name&quot;: &quot;method&quot;,\n          &quot;value&quot;: &quot;ping&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;reqMsg&quot;\n            },\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;resMsg&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;reqMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;resMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre><p>看上图我们能友好的得到结构、参数、数据类型、函数之间的依赖和关系，步骤：</p>\n<ul>\n<li>遍历词法分析得到的token数组，通过调用分析函数提取token之间的依赖节点</li>\n<li>分析函数内部定义token提取规则，比如：\n<ol>\n<li>服务保留字  服务名  { 函数保留字 函数名 ( 入参，返回参数 ) }</li>\n<li>参数结构保留字 结构名 { 参数位置 参数名 参数数据类型 }</li>\n</ol>\n</li>\n<li>递归调用分析函数提取对应节点依赖关系，将节点添加到AST中</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>[parser] (tokens) {\n    &#x2F;&#x2F; 声明ast对象，作为分析过程中的节点存储器\n    const ast = {\n      type: &#x27;Program&#x27;,\n      body: []\n    };\n    &#x2F;&#x2F; 定义token数组指针变量\n    let current = 0;\n    \n    &#x2F;&#x2F; 定义函数、用例递归分析节点之间的依赖和存储\n    function walk() {\n      &#x2F;&#x2F; 当前指针位置的token节点\n      let token = tokens[current];\n\n      &#x2F;&#x2F; 检查变量、数据类型\n      if (token.type === TYPE.VARIABLE) {\n        current++;\n        return {\n          type: EXP.VARIABLE,\n          struct: tokens[current].value === &#x27;=&#x27; ? false : true,\n          value: token.value\n        };\n      }\n\n      &#x2F;&#x2F; 检查符号\n      if (token.type === TYPE.SYMBOL) {\n        &#x2F;&#x2F; 检查@，添加参数位置绑定\n        if (token.value === &#x27;@&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token, 通常是个数值，也就是参数位置\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义参数节点，用来存储位置、变量名、数据类型\n          let node = {\n            type: EXP.VAR_DECLARATION,\n            name: &#x27;@&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token, 准备开始读取参数变量名和数据类型\n          token = tokens[++current];\n          &#x2F;&#x2F; 每个参数节点以;符号结束\n          &#x2F;&#x2F; 这个循环中会匹配参数变量名和参数数据类型并把他们添加到当前的参数节点上\n          while (token.value !== &#x27;;&#x27;) {\n            &#x2F;&#x2F; 递归匹配参数变量名、数据类型\n            node.params.push(walk());\n            &#x2F;&#x2F; 指定当前指针的token\n            token = tokens[current];\n          }\n          &#x2F;&#x2F; 移动token数组指针\n          current++;\n          &#x2F;&#x2F; 返回参数节点\n          return node;\n        }\n\n        &#x2F;&#x2F; 检查=，匹配该符号右边的参数数据类型\n        if (token.value === &#x27;=&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          current++;\n          return {\n            type: EXP.TYPE,\n            value: token.value\n          };\n        }\n\n        current++;\n      }\n\n      &#x2F;&#x2F; 检查保留字\n      if (token.type === TYPE.KEYWORD) {\n        &#x2F;&#x2F; 检查service、struct\n        if ([&#x27;struct&#x27;, &#x27;service&#x27;].indexOf(token.value) !== -1) {\n          &#x2F;&#x2F; 缓存保留字\n          let keywordName = token.value;\n          &#x2F;&#x2F; 移动到下一个token，通常是结构名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义结构节点，用来储存结构保留字、结构名、结构参数数组\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            &#x2F;&#x2F; 保留字\n            name: keywordName,\n            &#x2F;&#x2F; 结构名\n            value: token.value,\n            &#x2F;&#x2F; 参数数组\n            params: []\n          };\n\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配符号且是{,准备解析{里的参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;{&#x27;) {\n            &#x2F;&#x2F; 移动到下一个token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于}是退出参数匹配，完成参数储存\n            while (token.value !== &#x27;}&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数，获取参数数组\n              node.params.push(walk());\n              &#x2F;&#x2F; 移动token到当前指针\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回结构节点\n          return node;\n        }\n\n        if (token.value === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 检查method，匹配请求函数名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义请求函数节点，用来储存函数入参和返回参数\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            name: &#x27;method&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配(符号,准备储存入参和返回参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;(&#x27;) {\n            &#x2F;&#x2F; 移动到入参token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于)时退出匹配，完成函数匹配\n            while (token.value !== &#x27;)&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数\n              node.params.push(walk());\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回函数节点\n          return node;\n\n        }\n      }\n      \n      &#x2F;&#x2F; 抛出未匹配到的错误\n      throw new TypeError(token.type);\n    }\n\n    &#x2F;&#x2F; 遍历token数组\n    while (current &lt; tokens.length) {\n      ast.body.push(walk());\n    }\n    \n    &#x2F;&#x2F; 返回ast\n    return ast;\n  }\n</code></pre><h5>转换器</h5>\n<p>得到了语法分析的<code>AST</code>后我们需要进一步对<code>AST</code>转换为更易操作的<code>js对象</code>。格式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>{ \n    testService: { \n        ping: {\n            [Function]\n            param: { \n                reqMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                },\n                resMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                } \n            }\n        } \n    } \n}\n</code></pre><p>通过上面这个格式，我们可以更容易的知道有几个<code>service</code>、<code>service</code>里有多少个函数以及函数的参数。</p>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 转换器\n  [transformer] (ast) {\n    &#x2F;&#x2F; 定义汇总的service\n    const services = {};\n    &#x2F;&#x2F; 定义汇总的struct，用来储存参数结构，以便最后和service合并\n    const structs = {};\n\n    &#x2F;&#x2F; 转换数组\n    function traverseArray(array, parent) {\n      &#x2F;&#x2F; 遍历数组\n      array.some((child) =&gt; {\n        &#x2F;&#x2F; 分治转换单个节点\n        traverseNode(child, parent);\n      });\n    }\n\n    function traverseNode (node, parent) {\n\n      switch (node.type) {\n      case &#x27;Program&#x27;:\n        &#x2F;&#x2F; 根节点\n        traverseArray(node.body, parent);\n        break;\n      case &#x27;StructDeclaration&#x27;:\n        &#x2F;&#x2F; 匹配service、struct、method类型节点\n        if (node.name === &#x27;service&#x27;) {\n          &#x2F;&#x2F; 定义service的父节点为对象，为了更好的添加属性\n          parent[node.value] = {};\n          &#x2F;&#x2F; 调用数组转换函数解析，并把父节点传入以便添加子节点\n          traverseArray(node.params, parent[node.value]);\n        } else if (node.name === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 定义一个空函数给method节点\n          parent[node.value] = function () {};\n          &#x2F;&#x2F; 在该函数下挂载一个param属性作为函数的参数列表\n          parent[node.value].param = {};\n          traverseArray(node.params, parent[node.value].param);\n        } else if (node.name === &#x27;struct&#x27;) {\n          &#x2F;&#x2F; 定义struct的父节点为一个对象\n          structs[node.value] = {};\n          &#x2F;&#x2F; 解析struct\n          traverseArray(node.params, structs[node.value]);\n        }\n        break;\n      case &#x27;Identifier&#x27;:\n        &#x2F;&#x2F; 定义参数变量\n        parent[node.value] = {};\n        break;\n      case &#x27;VariableDeclaration&#x27;:\n        &#x2F;&#x2F; 解析参数数组\n        traverseArray(node.params, parent);\n        break;\n      case &#x27;DataType&#x27;:\n        &#x2F;&#x2F; 参数数据类型\n        parent[Object.keys(parent).pop()] = node.value;\n        break;\n      default:\n        &#x2F;&#x2F; 抛出未匹配到的错误\n        throw new TypeError(node.type);\n      }\n    }\n\n    traverseNode(ast, services);\n      \n    &#x2F;&#x2F; 合并service和struct\n    const serviceKeys = Object.getOwnPropertyNames(services);\n    serviceKeys.some(service =&gt; {\n      const methodKeys = Object.getOwnPropertyNames(services[service]);\n      methodKeys.some(method =&gt; {\n        Object.keys(services[service][method].param).some(p =&gt; {\n          if (structs[p] !== null) {\n            services[service][method].param[p] = structs[p];\n            delete structs[p];\n          }\n        });\n      });\n    });\n\n    return services;\n  }\n</code></pre><h4>传输协议</h4>\n<p><code>RPC</code>协议有多种，可以是<code>json、xml、http2</code>，相对于http1.x这种文本协议，http2.0这种二进制协议更适合作为<code>RPC</code>的应用层通信协议。很多成熟的<code>RPC</code>框架一般都会定制自己的协议已满足各种变化莫测的需求。</p>\n<p>比如<code>Thrift</code>的<code>TBinaryProtocol</code>、<code>TCompactProtocol</code>等，用户可以自主选择适合自己的传输协议。</p>\n<p>大多数计算机都是以字节编址的（除了按字节编址还有按字编址和按位编址），我们这里只讨论字节编址。每个机器因为不同的系统或者不同的CPU对内存地址的编码有不一样的规则，一般分为两种字节序：大端序和小端序。</p>\n<blockquote>\n<p>大端序: 数据的高字节保存在低地址</p>\n</blockquote>\n<blockquote>\n<p>小端序: 数据的低字节保存在高地址</p>\n</blockquote>\n<p>举个栗子：</p>\n<p>比如一个整数：<code>258</code>，用16进制表示为<code>0x0102</code>，我们把它分为两个字节<code>0x01</code>和<code>ox02</code>，对应的二进制为<code>0000 0001</code>和<code>0000 0010</code>。在大端序的电脑上存放形式如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/big.jpg\" alt=\"big\"></p>\n<p>小端序则相反。为了保证在不同机器之间传输的数据是一样的，开发一个通讯协议时会首先约定好使用一种作为通讯方案。<code>java虚拟机</code>采用的是大端序。在机器上我们称为<code>主机字节序</code>，网络传输时我们称为<code>网络字节序</code>。网络字节序是<code>TCP/IP</code>中规定好的一种数据表示格式，它与具体的<code>CPU</code>类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用大端排序方式。</p>\n<p>我们这里就不造新应用层协议的轮子了，我们直接使用<code>MQTT</code>协议作为我们的默认应用层协议。<code>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）</code>，是一种基于<code>发布/订阅</code>（<code>publish/subscribe</code>）模式的“轻量级”通讯协议，采用大端序的网络字节序传输，该协议构建于<code>TCP/IP</code>协议上。</p>\n<h4>实现通讯</h4>\n<p>先贴下实现完的代码调用流程，首先是server端：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\nconst server = new pRPC.Server();\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n\n&#x2F;&#x2F; 定义client端可以调用的函数\nfunction test(call, cb) {\n  cb(null, {age: call.age, name: call.name});\n}\n\n&#x2F;&#x2F; 加载kirito解析出来的对象和函数绑定，这里声明了ping的执行函数test\nserver.addKiritoService(proto.testService, {ping: test});\n\nserver.listen(10003);\n</code></pre><p>client端：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n&#x2F;&#x2F; 分配一个client实例绑定kirito解析的对象并连接server\nconst client =  new pRPC.Client({host: &#x27;localhost&#x27;, port: 10003}, proto.testService);\n\n&#x2F;&#x2F; 调用server端的函数\nclient.ping({age: 23, name: &#x27;ricky 泽阳&#x27;}, function (err, result) {\n  if (err) {\n    throw new Error(err.message);\n  }\n  console.log(result);\n});\n</code></pre><p>无论是server端定义函数或者client端调用函数都是比较简洁的步骤。接下来我们慢慢剖析具体的逻辑实现。</p>\n<p>贴下具体的调用流程架构图：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/mqt_rpc.jpg\" alt=\"rpc\"></p>\n<p>调用流程总结：</p>\n<ul>\n<li>client端解析kirito文件，绑定kirito的service到client对象</li>\n<li>server端解析kirito文件，将kiritod的service与调用函数绑定添加到server对象</li>\n<li>client端调用kirito service 里定义的函数，注册回调事件，发起MQTT请求</li>\n<li>server端接收MQTT请求，解析请求body，调用对应的函数执行完后向client端发起MQTT请求</li>\n<li>client端接收到MQTT请求后，解析body和error，并从回调事件队列里取出对应的回调函数并赋值执行</li>\n</ul>\n<p>说完了调用流程，现在开始讲解具体的实现。</p>\n<blockquote>\n<p><strong>server</strong>：</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\n&#x2F;&#x2F; 定义server类，继承EventEmitter是为了更好的将模块解耦\nclass MQTT extends EventEmitter {\n\n  constructor () {\n    super();\n    &#x2F;&#x2F; 是否已经开启服务\n    this.inited = false;\n    &#x2F;&#x2F; 函数集合\n    this.events = {};\n  }\n\n  &#x2F;&#x2F; 监听端口并开启服务\n  listen (port, cb) {\n    &#x2F;&#x2F; 已经初始化了就不用再次init\n    if (this.inited) {\n      cb &amp;&amp; cb(new Error(&#x27;already inited.&#x27;, null));\n      return;\n    }\n    &#x2F;&#x2F; 赋值当前作用域上下文的指针给self对象，用来在非当前作用的函数执行当前作用域的代码\n    const self = this;\n    &#x2F;&#x2F; 设置初始化\n    this.inited = true;\n    &#x2F;&#x2F; 实例化一个net服务\n    this.server = new net.Server();\n    this.port = port || 10003;\n    &#x2F;&#x2F; 监听端口\n    this.server.listen(this.port);\n    debug(&#x27;MQTT Server is started for port: %d&#x27;, this.port);\n      \n    &#x2F;&#x2F; 监听error事件\n    this.server.on(&#x27;error&#x27;, (err) =&gt; {\n      debug(&#x27;rpc server is error: %j&#x27;, err.stack);\n      self.emit(&#x27;error&#x27;, err);\n    });\n      \n    &#x2F;&#x2F; 监听连接事件\n    this.server.on(&#x27;connection&#x27;, (stream) =&gt; {\n      &#x2F;&#x2F; 实例化mqtt对象\n      const socket = mqttCon(stream);\n      debug(&#x27;=========== new connection ===========&#x27;);\n      \n      &#x2F;&#x2F; 监听mqtt服务connect事件\n      socket.on(&#x27;connect&#x27;, () =&gt; {\n        debug(&#x27;connected&#x27;);\n        socket.connack({ returnCode: 0 });\n      });\n\n      socket.on(&#x27;error&#x27;, (err) =&gt; {\n        debug(&#x27;error : %j&#x27;, err);\n        socket.destroy();\n      });\n\n      socket.on(&#x27;close&#x27;, () =&gt; {\n        debug(&#x27;===========     close     ============&#x27;);\n        socket.destroy();\n      });\n\n\n      socket.on(&#x27;disconnect&#x27;, () =&gt; {\n        debug(&#x27;===========   disconnect   ============&#x27;);\n        socket.destroy();\n      });\n        \n      &#x2F;&#x2F; 监听mqtt服务publish事件，接收client端请求\n      socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n        &#x2F;&#x2F; 消费client端的请求\n        self.consumers(pkg, socket);\n      });\n    });\n  }\n    \n  &#x2F;&#x2F; 消费client端的请求\n  consumers (pkg, socket) {\n    &#x2F;&#x2F; 赋值当前作用的指针给self对象\n    const self = this;\n    &#x2F;&#x2F; 将client的数据包转成json字符，字节序不同的处理已经在mqtt的底层转换好了\n    let content = pkg.payload.toString();\n    debug(content);\n    content = JSON.parse(content);\n    &#x2F;&#x2F; 定义响应数据包\n    const respMsg = {\n      msgId: content.msgId\n    };\n    &#x2F;&#x2F; 如果请求调用的函数不存在则加上错误消息响应回去client端\n    if (this.events[content.method] === null) {\n      &#x2F;&#x2F; 定义调用错误消息\n      respMsg.error = {\n        message: &#96;not found ${content.method} method&#96;\n      };\n      &#x2F;&#x2F; 推送到client端\n      self.response(socket, {messageId: pkg.messageId, body: respMsg});\n    } else {\n      &#x2F;&#x2F; 如果存在有效的函数则准备调用\n      const fn = this.events[content.method].method;\n      &#x2F;&#x2F; 设置调用函数的回调事件，用来处理调用函数完成后的参数返回\n      const callback = function (err, result) {\n        &#x2F;&#x2F; 获取调用完后的参数结果\n        respMsg.body = result;\n        &#x2F;&#x2F; 推送到client端\n        self.response(socket, {messageId: pkg.messageId, body: respMsg});\n      };\n      &#x2F;&#x2F; 执行调用参数\n      fn.call(fn, content.body, callback);\n    }\n  }\n    \n  &#x2F;&#x2F; 推送调用结果数据包给client端\n  response (socket, result) {\n    socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: result.messageId,\n      payload: JSON.stringify(result.body)\n    });\n  }\n\n\n  &#x2F;&#x2F; 绑定kirito定义的函数集合\n  addEvent (events) {\n    const eventKeys = Object.getOwnPropertyNames(events);\n    eventKeys.some(event =&gt; {\n      this.events[event] = {\n        method: events[event].method,\n        param: events[event].param\n      };\n    });\n  }\n\n}\n\nmodule.exports.create = function () {\n  return new MQTT();\n};\n</code></pre><p>定义protocol接口，加上这一层是为了以后的多协议，mqtt只是默认使用的协议：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n</code></pre><p>接下来是server端的暴露出去的接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\n\n&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\n\nclass Server {\n\n  constructor () {\n    &#x2F;&#x2F; 实例化协议对象\n    this.server = protocol.create();\n  }\n    \n  &#x2F;&#x2F; 将kirito定义的接口和函数集合绑定\n  addKiritoService (service, methods) {\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    const methodKeys = Object.getOwnPropertyNames(methods);\n    const events = {};\n    serviceKeys.some(method =&gt; {\n      let idx = -1;\n      if ((idx = methodKeys.indexOf(method)) !== -1) {\n        events[method] = {\n          method: methods[method],\n          param: service[method].param\n        };\n        methodKeys.splice(idx, 1);\n      }\n    });\n    if (Object.keys(events).length &gt; 0) {\n      this.server.addEvent(events);\n    }\n  }\n\n  listen (port) {\n    this.server.listen(port);\n  }\n\n}\n\nmodule.exports = Server;\n</code></pre><blockquote>\n<p><strong>client</strong>：</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\nclass MQTT extends EventEmitter {\n\n  constructor (server) {\n    super();\n    &#x2F;&#x2F; 获取server端连接信息\n    this.host = server.host || &#x27;localhost&#x27;;\n    this.port = server.port || 10003;\n    &#x2F;&#x2F; 是否服务已连接\n    this.connected = false;\n    &#x2F;&#x2F; 是否服务已关闭\n    this.closed = false;\n  }\n    \n  &#x2F;&#x2F; 连接server服务\n  connect (cb) {\n    &#x2F;&#x2F; 连接了就不用再次执行连接\n    if (this.connected) {\n      cb &amp;&amp; cb (new Error(&#x27;mqtt rpc has already connected&#x27;), null);\n      return;\n    }\n\n    &#x2F;&#x2F; 复制当前作用域上下文的指针给self变量\n    const self = this;\n    &#x2F;&#x2F; 获取net服务连接流\n    const stream = net.createConnection(this.port, this.host);\n    &#x2F;&#x2F; 初始化mqtt服务\n    this.socket = mqttCon(stream);\n    &#x2F;&#x2F; 监听conack事件\n    this.socket.on(&#x27;connack&#x27;, (pkg) =&gt; {\n      debug(&#x27;conack: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 监听error事件\n    this.socket.on(&#x27;error&#x27;, function (err) {\n      debug(&#x27;error: %j&#x27;, err);\n    });\n\n\n    &#x2F;&#x2F; 监听publish事件，接收server端调用函数结果的返回数据\n    this.socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n      &#x2F;&#x2F; 将数据包转成json字符\n      const content = pkg.payload.toString();\n      debug(content);\n      &#x2F;&#x2F; 将数据转发到MQTT的对象事件上\n      this.emit(&#x27;data&#x27;, JSON.parse(content));\n    });\n\n    &#x2F;&#x2F; 监听puback事件\n    this.socket.on(&#x27;puback&#x27;, (pkg) =&gt; {\n      debug(&#x27;puback: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 发起连接\n    this.socket.connect({\n      clientId: &#x27;MQTT_RPC_&#x27; + Math.round(new Date().getTime() &#x2F; 1000)\n    }, () =&gt; {\n      if (self.connected) {\n        return;\n      }\n        \n      &#x2F;&#x2F; 设置已连接\n      self.connected = true;\n\n      cb &amp;&amp; cb(null, {connected: self.connected});\n    });\n  }\n    \n  &#x2F;&#x2F; 发起调用函数请求\n  send (param) {\n    this.socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: 1,\n      payload: JSON.stringify(param || {})\n    });\n  }\n\n  &#x2F;&#x2F; 关闭连接\n  close () {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    this.connected = false;\n    this.socket.destroy();\n  }\n\n}\n\nmodule.exports.create = function (server) {\n  return new MQTT(server || {});\n};\n</code></pre><p>定义protocol接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n</code></pre><p>最后是client端暴露的接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\nconst connect = Symbol.for(&#x27;connect&#x27;);\nconst uuid = require(&#x27;uuid&#x2F;v1&#x27;);\n\nclass Client {\n\n  constructor(opts, service) {\n    &#x2F;&#x2F; 声明client实例\n    this.client = void(0);\n    &#x2F;&#x2F; 调用协议连接接口\n    this[connect](opts, service);\n    &#x2F;&#x2F; 定义回调参数集合\n    this.callQueues = {};\n  }\n\n  &#x2F;&#x2F; 连接server\n  [connect] (opts, service) {\n    &#x2F;&#x2F; 初始化协议服务\n    this.client = protocol.create(opts);\n    &#x2F;&#x2F; 发起连接\n    this.client.connect((err) =&gt; {\n      if (err) {\n        throw new Error(err);\n      }\n    });\n      \n    &#x2F;&#x2F; 复制当前作用域的上下文指针给self对象\n    const self = this;\n\n    &#x2F;&#x2F; 监听协议data时间，接收协议转发server端响应的数据\n    this.client.on(&#x27;data&#x27;, function (result) {\n      &#x2F;&#x2F; 听过msgId取出回调函数\n      const fn = self.callQueues[result.msgId];\n      &#x2F;&#x2F; 如果有调用错误信息，则直接回调错误\n      if (result.error) {\n        return fn.call(fn, result.error, null);\n      }\n      &#x2F;&#x2F; 执行回调\n      fn.call(fn, null, result.body);\n    });\n    &#x2F;&#x2F; 绑定kirito定义的接口参数到协议对象中\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    serviceKeys.some(method =&gt; {\n      &#x2F;&#x2F; 增加client端的函数，对应server端的调用函数\n      self[method] = function () {\n        &#x2F;&#x2F; 取出发送的数据\n        const reqMsg = arguments[0];\n        &#x2F;&#x2F; 取出回调函数\n        const fn = arguments[1];\n        const paramKey = Object.getOwnPropertyNames(service[method].param);\n        paramKey.some((param) =&gt; {\n          if (reqMsg[param] === null) {\n            throw new Error(&#96;Parameters &#x27;${param}&#x27; are missing&#96;);\n          }\n          &#x2F;&#x2F; todo 类型判断及转换\n        });\n        &#x2F;&#x2F; 为每个请求标记\n        const msgId = uuid();\n        &#x2F;&#x2F; 注册该请求的回调函数到回调队列中\n        self.callQueues[msgId] = fn;\n        &#x2F;&#x2F; 发起调用函数请求\n        self.client.send({method, msgId, body: reqMsg});\n      };\n    });\n  }\n\n}\n\nmodule.exports = Client;\n</code></pre><p>就这样，一个简单的IDL+RPC框架就这样搭建完成了。这里只是描述RPC的原理和常用的调用方式，要想用在企业级的开发上，还得加上服务发现、注册，服务熔断，服务降级等，读者如果有兴趣可以在Github上fork下来或者提PR来改进这个框架，有什么问题也可以提Issue, 当然PR是最好的 : ) 。</p>\n<p>仓库地址：</p>\n<p>RPC: <a href=\"https://github.com/polixjs/polix-rpc\">https://github.com/polixjs/polix-rpc</a></p>\n<p>IDL: <a href=\"https://github.com/rickyes/kiritobuf\">https://github.com/rickyes/kiritobuf</a></p>\n</div>","title":"从零开始实现一个IDL+RPC框架","last_reply_at":"2019-04-02T10:07:51.760Z","good":true,"top":false,"reply_count":33,"visit_count":5129,"create_at":"2018-08-03T01:39:42.660Z","author":{"loginname":"zhoumingque","avatar_url":"https://avatars3.githubusercontent.com/u/20432815?v=4&s=120"}},{"id":"5ca2caf86c1de62dce466c76","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h2>Introduction</h2>\n<p>面试过程通常从最初的电话面试开始，然后是现场面试，检查编程技能和文化契合度。几乎毫无例外，最终的决定因素是还是编码能力。通常上，不仅仅要求能得到正确的答案，更重要的是要有清晰的思维过程。写代码中就像在生活中一样，正确的答案并不总是清晰的，但是好的推理通常就足够了。有效推理的能力预示着学习、适应和进化的潜力。好的工程师一直是在成长的，好的公司总是在创新的。</p>\n<p>算法挑战是有用的，因为解决它们的方法不止一种。这为决策的制定和决策的计算提供了可能性。在解决算法问题时，我们应该挑战自己从多个角度来看待问题的定义，然后权衡各种方法的优缺点。通过足够的尝试后，我们甚至可能看到一个普遍的真理:不存在“完美”的解决方案。</p>\n<p>要真正掌握算法，就必须了解它们与数据结构的关系。数据结构和算法就像阴阳、水杯和水一样密不可分。没有杯子，水就不能被容纳。没有数据结构，我们就没有对象来应用逻辑。没有水，杯子是空的，没有营养。没有算法，对象就不能被转换或“消费”。</p>\n<p>要了解和分析JavaScript中的数据结构，请看<a href=\"https://github.com/lvwxx/blog/issues/1\">JavaScript中的数据结构</a></p>\n<h2>Primer</h2>\n<p>在<strong>JavaScript</strong>中，算法只是一个函数，它将某个确定的数据结构输入转换为某个确定的数据结构输出。函数内部的逻辑决定了怎么转换。首先，输入和输出应该清楚地提前定义。这需要我们充分理解手上的问题，因为对问题的全面分析可以很自然地提出解决方案，而不需要编写任何代码。</p>\n<p>一旦完全理解了问题，就可以开始对解决方案进行思考，需要那些变量？ 有几种循环？ 有那些JavaScript内置方法可以提供帮助？需要考虑那些边缘情况？复杂或者重复的逻辑会导致代码十分的难以阅读和理解，可以考虑能否提出抽象成多个函数？一个算法通常上需要可扩展的。随着输入<strong>size</strong>的增加，函数将如何执行? 是否应该有某种缓存机制吗? 通常上，需要牺牲内存优化(空间)来换取性能提升(时间)。</p>\n<h3>为了使问题更加具体，画图表！</h3>\n<p>当解决方案的具体结构开始出现时，伪代码就可以开始了。为了给面试官留下深刻印象，请提前寻找重构和重用代码的机会。有时，行为相似的函数可以组合成一个更通用的函数，该函数接受一个额外的参数。其他时候，函数柯里的效果更好。保证函数功能的纯粹方便测试和维护也是非常重要的。换句话说，在做出解决问题的决策时需要考虑到架构和设计模式。</p>\n<h3>Big O（复杂度）</h3>\n<p>为了计算出算法运行时的复杂性，我们需要将算法的输入大小外推到无穷大，从而近似得出算法的复杂度。最优算法有一个恒定的时间复杂度和空间复杂度。这意味着它不关心输入的数量增长多少，其次是对数时间复杂度或空间复杂度，然后是线性、二次和指数。最糟糕的是阶乘时间复杂度或空间复杂度。算法复杂度可用以下符号表示:</p>\n<ol>\n<li>Constabt: O(1)</li>\n<li>Logarithmic: O(log n)</li>\n<li>Linear: O(n)</li>\n<li>Linearithmic: O(n log n)</li>\n<li>Quadratic: O(n^2)</li>\n<li>Expontential: O(2^n)</li>\n<li>Factorial: O(n!)</li>\n</ol>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-j3Q4EiyBgc1tDTR5uKTnQ.png\" alt=\"''\"></p>\n<p>在设计算法的结构和逻辑时，时间复杂度和空间复杂度的优化和权衡是一个重要的步骤。</p>\n<h3>Arrays</h3>\n<p>一个最优的算法通常上会利用语言里固有的标准对象实现。可以说，在计算机科学中最重要的是数组。在JavaScript中，没有其他对象比数组拥有更多的实用方法。值得记住的数组方法有:sort、reverse、slice和splice。数组元素从第0个索引开始插入，所以最后一个元素的索引是 array.length-1。数组在push元素有很好的性能，但是在数组中间插入，删除和查找元素上性能却不是很优，JavaScript中的数组的大小是可以动态增长的。</p>\n<h4>数组的各种操作复杂度</h4>\n<ul>\n<li>Push: O(1)</li>\n<li>Insert: O(n)</li>\n<li>Delet: O(n)</li>\n<li>Searching: O(n)</li>\n<li>Optimized Searching: O(log n)</li>\n</ul>\n<p><strong>Map</strong> 和 <strong>Set</strong>是和数组相似的数据结构。set中的元素都是不重复的，在map中，每个Item由键和值组成。当然，对象也可以用来存储键值对，但是键必须是字符串。</p>\n<h3>Iterations</h3>\n<p>与数组密切相关的是使用循环遍历它们。在JavaScript中,有5种最常用的遍历方法，使用最多的是<strong>for</strong>循环，for循环可以用任何顺序遍历数组的索引。如果无法确定迭代的次数，我们可以使用<strong>while</strong>和<strong>do while</strong>循环，直到满足某个条件。对于任何<strong>Object</strong>, 我们可以使用 <strong>for in</strong> 和 <strong>for of</strong>循环遍历它的keys 和values。为了同时获取key和value我们可以使用 <strong>entries()</strong>。我们也可以在任何时候使用<strong>break</strong>语句终止循环，或者使用<strong>continue</strong>语句跳出本次循环进入下一次循环。</p>\n<p>原生数组提供了如下迭代方法：<strong>indexOf,lastIndexOf,includes,fill,join</strong>。 另外我们可以提供一个回调函数在如下方法中：<strong>findIndex,find,filter,forEach,map,some,every,reduce</strong>。</p>\n<h3>Recursions</h3>\n<p>在一篇开创性的论文中，Church-Turing论文证明了任何迭代函数都可以用递归函数来复制，反之亦然。有时候，递归方法更简洁、更清晰、更优雅。以这个迭代阶乘函数为例:</p>\n<pre class=\"prettyprint language-js\"><code>const factorial = number =&gt; {\n  let product = 1\n  for (let i = 2; i &lt;= number; i++) {\n    product *= i\n  }\n  return product\n}\n</code></pre><p>如果使用递归，仅仅需要一行代码</p>\n<pre class=\"prettyprint language-js\"><code>const _factorial = number =&gt; {\n  return number &lt; 2 ? 1 : number * _factorial(number - 1)\n}\n</code></pre><p>所有的递归函数都有相同的模式。它们由创建一个调用自身的递归部分和一个不调用自身的基本部分组成。任何时候一个函数调用它自身都会创建一个新的执行上下文并推入执行栈顶直。这种情况会一直持续到直到满足了基本情况为止。然后执行栈会一个接一个的将栈顶元素推出。因此，对递归的滥用可能导致堆栈溢出的错误。</p>\n<h3>最后，我们一起来思考一些常见算法题！</h3>\n<h4>1. 字符串反转</h4>\n<p>一个函数接受一个字符串作为参数，返回反转后的字符串</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;String Reversal&quot;, () =&gt; {\n it(&quot;Should reverse string&quot;, () =&gt; {\n  assert.equal(reverse(&quot;Hello World!&quot;), &quot;!dlroW olleH&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>这道题的关键点是我们可以使用数组自带的<strong>reverse</strong>方法。首先我们使用 <strong>split</strong>方法将字符串转为数组，然后使用reverse反转字符串，最后使用<strong>join</strong>方法转为字符串。另外也可以使用数组的<strong>reduce</strong>方法</p>\n<p>给定一个字符串，每个字符需要访问一次。虽然这种情况发生了很多次，但是时间复杂度会正常化为线性。由于没有单独的内部数据结构，空间复杂度是恒定的。</p>\n<pre class=\"prettyprint language-js\"><code>const reverse = string =&gt; string.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)\n\nconst _reverse = string =&gt; string.split(&#x27;&#x27;).reduce((res,char) =&gt; char + res)\n</code></pre><h4>2. 回文</h4>\n<p>回文是一个单词或短语，它的读法是前后一致的。写一个函数来检查。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Palindrome&quot;, () =&gt; {\n it(&quot;Should return true&quot;, () =&gt; {\n  assert.equal(isPalindrome(&quot;Cigar? Toss it in a can. It is so tragic&quot;), true);\n })\n it(&quot;Should return false&quot;, () =&gt; {\n  assert.equal(isPalindrome(&quot;sit ad est love&quot;), false);\n })\n})\n</code></pre><h5>思考</h5>\n<p>函数只需要简单地判断输入的单词或短语反转之后是否和原输入相同，完全可以参考第一题的解决方案。我们可以使用数组的 <strong>every</strong> 方法检查第i个字符和第array.length-i个字符是否匹配。但是这个方法会使每个字符检查2次，这是没必要的。那么，我们可以使用reduce方法。和第1题一样，时间复杂度和空间复杂度是相同的。</p>\n<pre class=\"prettyprint language-js\"><code>const isPalindrome = string =&gt; {\n  const validCharacters = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)\n  const stringCharacters = string &#x2F;&#x2F; 过滤掉特殊符号\n      .toLowerCase()\n      .split(&quot;&quot;)\n      .reduce(\n        (characters, character) =&gt;\n          validCharacters.indexOf(character) &gt; -1\n            ? characters.concat(character)\n            : characters,\n        []\n      );\n  return stringCharacters.join(&quot;&quot;) === stringCharacters.reverse().join(&quot;&quot;)\n</code></pre><h4>3. 整数反转</h4>\n<p>给定一个整数，反转数字的顺序。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Integer Reversal&quot;, () =&gt; {\n it(&quot;Should reverse integer&quot;, () =&gt; {\n  assert.equal(reverse(1234), 4321);\n  assert.equal(reverse(-1200), -21);\n })\n})\n</code></pre><h5>思考</h5>\n<p>把number类型使用<strong>toString</strong>方法换成字符串，然后就可以按照字符串反转的步骤来做。反转完成之后，使用<strong>parseInt</strong>方法转回number类型，然后使用<strong>Math.sign</strong>加入符号，只需一行代码便可完成。</p>\n<p>由于我们重用了字符串反转的逻辑，因此该算法在空间和时间上也具有相同的复杂度。</p>\n<pre class=\"prettyprint language-js\"><code>const revserInteger = integer =&gt; parseInt(number\n      .toString()\n      .split(&#x27;&#x27;)\n      .reverse()\n      .join(&#x27;&#x27;)) * Math.sign(integer)\n</code></pre><h4>4. 出现次数最多的字符</h4>\n<p>给定一个字符串，返回出现次数最多的字符</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Max Character&quot;, () =&gt; {\n it(&quot;Should return max character&quot;, () =&gt; {\n  assert.equal(max(&quot;Hello World!&quot;), &quot;l&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>可以创建一个对象，然后遍历字符串，字符串的每个字符作为对象的key，value是对应该字符出现的次数。然后我们可以遍历这个对象，找出value最大的key。</p>\n<p>虽然我们使用两个单独的循环来迭代两个不同的输入(字符串和字符映射)，但是时间复杂度仍然是线性的。它可能来自字符串，但最终，字符映射的大小将达到一个极限，因为在任何语言中只有有限数量的字符。空间复杂度是恒定的。</p>\n<pre class=\"prettyprint language-js\"><code>const maxCharacter = (str) =&gt; {\n    const obj = {}\n    let max = 0\n    let character = &#x27;&#x27;\n    for (let index in str) {\n      obj[str[index]] = obj[str[index]] + 1 || 1\n    }\n    for (let i in obj) {\n      if (obj[i] &gt; max) {\n        max = obj[i]\n        character = i\n      }\n    }\n    return character\n  }\n</code></pre><h4>5.找出string中元音字母出现的个数</h4>\n<p>给定一个单词或者短语，统计出元音字母出现的次数</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Vowels&quot;, () =&gt; {\n it(&quot;Should count vowels&quot;, () =&gt; {\n  assert.equal(vowels(&quot;hello world&quot;), 3);\n })\n})\n</code></pre><h5>思考</h5>\n<p>最简单的解决办法是利用正则表达式提取所有的元音，然后统计。如果不允许使用正则表达式，我们可以简单的迭代每个字符并检查是否属于元音字母，首先应该把输入的参数转为小写。</p>\n<p>这两种方法都具有线性的时间复杂度和恒定的空间复杂度，因为每个字符都需要检查，临时基元可以忽略不计。</p>\n<pre class=\"prettyprint language-js\"><code>  const vowels = str =&gt; {\n    const choices = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;]\n    let count = 0\n    for (let character in str) {\n      if (choices.includes(str[character])) {\n        count ++\n      }\n    }\n    return count\n  }\n\n  const vowelsRegs = str =&gt; {\n    const match = str.match(&#x2F;[aeiou]&#x2F;gi)\n    return match ? match.length : 0\n  }\n</code></pre><h4>6.数组分隔</h4>\n<p>给定数组和大小，将数组项拆分为具有给定大小的数组列表。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Array Chunking&quot;, () =&gt; {\n it(&quot;Should implement array chunking&quot;, () =&gt; {\n  assert.deepEqual(chunk([1, 2, 3, 4], 2), [[1, 2], [3, 4]]);\n  assert.deepEqual(chunk([1, 2, 3, 4], 3), [[1, 2, 3], [4]]);\n  assert.deepEqual(chunk([1, 2, 3, 4], 5), [[1, 2, 3, 4]]);\n })\n})\n</code></pre><p>一个好的解决方案是使用内置的slice方法。这样就能生成更干净的代码。可通过while循环或for循环来实现，它们按给定大小的步骤递增。</p>\n<p>这些算法都具有线性时间复杂度，因为每个数组项都需要访问一次。它们还具有线性空间复杂度，因为保留了一个内部的“块”数组，它与输入数组成比例地增长。</p>\n<pre class=\"prettyprint language-js\"><code>const chunk = (array, size) =&gt; {\n  const chunks = []\n  let index = 0\n   while(index &lt; array.length) {\n     chunks.push(array.slice(index, index + size))\n     index += size\n   }\n   return chunks\n}\n</code></pre><h4>7.words反转</h4>\n<p>给定一个短语，按照顺序反转每一个单词</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Reverse Words&quot;, () =&gt; {\n it(&quot;Should reverse words&quot;, () =&gt; {\n  assert.equal(reverseWords(&quot;I love JavaScript!&quot;), &quot;I evol !tpircSavaJ&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>可以使用split方法创建单个单词数组。然后对于每一个单词，可以复用之前反转string的逻辑。</p>\n<p>因为每一个字符都需要被访问，而且所需的临时变量与输入的短语成比例增长，所以时间复杂度和空间复杂度是线性的。</p>\n<pre class=\"prettyprint language-js\"><code>const reverseWords = string =&gt; string\n                                  .split(&#x27; &#x27;)\n                                  .map(word =&gt; word\n                                                .split(&#x27;&#x27;)\n                                                .reverse()\n                                                .join(&#x27;&#x27;)\n                                      ).join(&#x27; &#x27;)\n\n</code></pre><h4>8.首字母大写</h4>\n<p>给定一个短语，每个首字母变为大写。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Capitalization&quot;, () =&gt; {\n it(&quot;Should capitalize phrase&quot;, () =&gt; {\n  assert.equal(capitalize(&quot;hello world&quot;), &quot;Hello World&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>一种简洁的方法是将输入字符串拆分为单词数组。然后，我们可以循环遍历这个数组并将第一个字符大写，然后再将这些单词重新连接在一起。出于不变的相同原因，我们需要在内存中保存一个包含适当大写字母的临时数组。</p>\n<p>因为每一个字符都需要被访问，而且所需的临时变量与输入的短语成比例增长，所以时间复杂度和空间复杂度是线性的。</p>\n<pre class=\"prettyprint language-js\"><code>const capitalize = str =&gt; {\n  return str.split(&#x27; &#x27;).map(word =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;)\n}\n</code></pre><h4>9.凯撒密码</h4>\n<p>给定一个短语，通过在字母表中上下移动一个给定的整数来替换每个字符。如果有必要，这种转换应该回到字母表的开头或结尾。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Caesar Cipher&quot;, () =&gt; {\n it(&quot;Should shift to the right&quot;, () =&gt; {\n  assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, 100), &quot;E hkra FwrwOynelp!&quot;)\n })\nit(&quot;Should shift to the left&quot;, () =&gt; {\n  assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, -100), &quot;M pszi NezeWgvmtx!&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>首先我们需要一个包含所有字母的数组，这意味着我们需要把给定的字符串转为小写，然后遍历整个字符串，给每个字符增加或减少给定的整数位置，最后判断大小写即可。</p>\n<p>由于需要访问输入字符串中的每个字符，并且需要从中创建一个新的字符串，因此该算法具有线性的时间和空间复杂度。</p>\n<pre class=\"prettyprint language-js\"><code>const caesarCipher = (str, number) =&gt; {\n  const alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)\n    const string = str.toLowerCase()\n    const remainder = number % 26\n    let outPut = &#x27;&#x27;\n    for (let i = 0; i &lt; string.length; i++) {\n      const letter = string[i]\n      if (!alphabet.includes(letter)) {\n        outPut += letter\n      } else {\n        let index = alphabet.indexOf(letter) + remainder\n        if (index &gt; 25) {\n          index -= 26\n        }\n        if (index &lt; 0) {\n          index += 26\n        }\n        outPut += str[i] === str[i].toUpperCase() ? alphabet[index].toUpperCase() : alphabet[index]\n      }\n    }\n  return outPut\n}\n</code></pre><h4>10.找出从0开始到给定整数的所有质数</h4>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Sieve of Eratosthenes&quot;, () =&gt; {\n it(&quot;Should return all prime numbers&quot;, () =&gt; {\n  assert.deepEqual(primes(10), [2, 3, 5, 7])\n })\n})\n</code></pre><h5>思考</h5>\n<p>最简单的方法是我们循环从0开始到给定整数的每个整数，并创建一个方法检查它是否是质数。</p>\n<pre class=\"prettyprint language-js\"><code>const isPrime = n =&gt; {\n  if (n &gt; 1 &amp;&amp; n &lt;= 3) {\n      return true\n    } else {\n      for(let i = 2;i &lt;= Math.sqrt(n);i++){\n        if (n % i == 0) {\n          return false\n        }\n      }\n      return true\n  }\n}\n\nconst prime = number =&gt; {\n  const primes = []\n  for (let i = 2; i &lt; number; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n</code></pre><h4>自己实现一个高效的斐波那契队列，欢迎在评论区提交代码</h4>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Fibonacci&quot;, () =&gt; {\n it(&quot;Should implement fibonacci&quot;, () =&gt; {\n  assert.equal(fibonacci(1), 1);\n  assert.equal(fibonacci(2), 1);\n  assert.equal(fibonacci(3), 2);\n  assert.equal(fibonacci(6), 8);\n  assert.equal(fibonacci(10), 55);\n })\n})\n</code></pre></div>","title":"JavaScript中的算法（附10道面试常见算法题解决方法和思路）","last_reply_at":"2019-04-02T10:00:32.523Z","good":false,"top":false,"reply_count":8,"visit_count":400,"create_at":"2019-04-02T02:37:44.112Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca3157831010b2dfbb424bf","author_id":"5c47dd816955112b99437e7f","tab":"ask","content":"<div class=\"markdown-text\"><p>node集群起了服务，每个服务上重复订阅了redis的过期通知，然后当redis的发布过期通知时，会向每个服务发送过期通知吗？如何解决服务重复消费redis的过期通知？</p>\n</div>","title":"node集群下重复消费redis的过期通知","last_reply_at":"2019-04-02T07:55:36.744Z","good":false,"top":false,"reply_count":0,"visit_count":222,"create_at":"2019-04-02T07:55:36.744Z","author":{"loginname":"jiazhuoyi","avatar_url":"https://avatars1.githubusercontent.com/u/17874998?v=4&s=120"}},{"id":"5c0a929c15a4d545e3f4c5d6","author_id":"5bc9f0ca9545eaf107b9ccdd","tab":"ask","content":"<div class=\"markdown-text\"><p>如何学习</p>\n</div>","title":"如何学习vue框架","last_reply_at":"2019-04-02T07:15:28.662Z","good":false,"top":false,"reply_count":23,"visit_count":2019,"create_at":"2018-12-07T15:32:44.120Z","author":{"loginname":"hhffhh","avatar_url":"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}},{"id":"5c98303afd41137eb76611c5","author_id":"5c8b07957ce0df37324281f2","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://www.bilibili.com/video/av47250164?from=search&amp;seid=5656787623889941077\">https://www.bilibili.com/video/av47250164?from=search&amp;seid=5656787623889941077</a></p>\n<p>Nodejs直播系统开发有人会吗?不知道 Nodejs搭建的直播系统性能怎么样?</p>\n</div>","title":"Nodejs直播系统开发有人会吗?B站已经有Nodejs实现（摄像机）监控直播管理系统","last_reply_at":"2019-04-02T06:57:34.493Z","good":false,"top":false,"reply_count":7,"visit_count":1248,"create_at":"2019-03-25T01:34:50.259Z","author":{"loginname":"xuemeifenglin","avatar_url":"https://avatars3.githubusercontent.com/u/48575523?v=4&s=120"}},{"id":"5bb0bf6f37a6965f59051df3","author_id":"5ba61ea38f5b0c1c59ea10b6","tab":"share","content":"<div class=\"markdown-text\"><h2>在线体验地址:<a href=\"http://vip.52tech.tech/\">http://vip.52tech.tech/</a></h2>\n<h2>GIthub源码：<a href=\"https://github.com/xiugangzhang/vip.github.io\">https://github.com/xiugangzhang/vip.github.io</a></h2>\n<h2>项目预览</h2>\n<p><img src=\"//static.cnodejs.org/FmjZMm4b3MUqJIuSB5aYS2PEW0pf\" alt=\"preview.jpg\"></p>\n<ul>\n<li>主页面\n<img src=\"//static.cnodejs.org/FhTjrj9HgY37ojGYNdLWupmBfSyv\" alt=\"preview.jpg\"></li>\n<li>登录页面\n<img src=\"//static.cnodejs.org/FrZr5Mck4VQD9ndVXhJGqA9XwHsU\" alt=\"login.jpg\"></li>\n<li>注册页面\n<img src=\"//static.cnodejs.org/FnXwM1CtMBcA7cFv66vlYb-t559E\" alt=\"register.jpg\"></li>\n<li>会员中心\n<img src=\"//static.cnodejs.org/FtCfCUeeIA8Y0WnYkhvzqlweqPbs\" alt=\"user.jpg\"></li>\n<li>电影播放页面\n<img src=\"//static.cnodejs.org/FryrTyzEeEFuOgD1uXrkwF4MzXn-\" alt=\"play.jpg\"></li>\n<li>电影弹幕功能\n<img src=\"//static.cnodejs.org/FhcOXAvbMZuafMrJzU00fMvRXot9\" alt=\"danmu.jpg\"></li>\n</ul>\n<h2>视频网站项目已经完功能如下：</h2>\n<h3>v1.0.3（当前最新版本）</h3>\n<ul>\n<li>\n<ol>\n<li>增加自动抓取功能，网站数据定期实时更新</li>\n</ol>\n<ul>\n<li>电影和电视剧数据抓取</li>\n<li>电影数据信息前端展现</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影页面图片的自动抓取、下载和展示</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>代码结构调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.2</h3>\n<ul>\n<li>\n<ol>\n<li>简化程序安装流程，新增可视化安装界面</li>\n</ol>\n<ul>\n<li>用户可直接输入数据库名、数据库地址、数据库用户名、数据库密码信息一键完成程序的安装</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>页面部分结构的调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.1</h3>\n<ul>\n<li>\n<ol>\n<li>用户中心的管理</li>\n</ol>\n<ul>\n<li>对于已经注册的用户，实现用户基本信息的修改</li>\n<li>用户密码的修改</li>\n<li>用户评论记录的查看</li>\n<li>用户收藏电影的查看和播放</li>\n<li>用户登录日志的查看</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影搜索功能（特色功能）</li>\n</ol>\n<ul>\n<li>实现了根据视频播放地址和视频名称全网视频的搜索和播放功能</li>\n<li>实现了正在热映，即将上映和TOP250的电影列表的展示</li>\n<li>电影收藏和取消功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>弹幕功能（特色功能）</li>\n</ol>\n<ul>\n<li>类似于B站等其他视频网站的弹幕功能，用户在登录之后可以实现在线发言</li>\n</ul>\n</li>\n</ul>\n<h3>v1.0.0</h3>\n<ul>\n<li>\n<ol>\n<li>用户主页的搭建：</li>\n</ol>\n<ul>\n<li>实现了主页轮播图的显示和切换，用户可以从数据库中自由配置和切换轮播图的显示</li>\n<li>实现了主页电影列表的显示：从数据库文件读取电影和电视剧列表信息并在前台显示</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>用户登录和注册页面的搭建：</li>\n</ol>\n<ul>\n<li>实现了用户的登录和注册功能</li>\n<li>用户注册和登录验证码提示功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影播放页面的搭建</li>\n</ol>\n<ul>\n<li>对于其他页面的任意可以展现电影列表的页面，用户可以直接点击列表，直接进入播放页面</li>\n<li>播放页面电影详细信息的展现</li>\n<li>对于加载速度较慢的视频，用户可以自由切换播放接口进行加速</li>\n<li>用户可以在相应的播放页面查看其他用户已经发表的评论，同时也可以在登录之后自由发表评论</li>\n</ul>\n</li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li>\n<ol>\n<li>页面整体的风格模仿了Discuz等论坛网站的布局</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>网站首页的轮播图效果模仿了优酷、爱奇艺、腾讯视频等主流视频网站的轮播图效果，并且对该部分的效果实现进行了代码封装</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影底部的的友情链接，使用了大部分网站的分栏布局，用户可以添加自己的QQ群以及微信公众号方便增加自己网站的人气</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>主要列表的分页功能，对于一些内容显示较多的不能再一页显示完整的页面，使用了ajax无刷新分页对数据进行多条展示，提高了用户的体验</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>目前主流浏览器中也做了相应测试，建议大家使用谷歌或者火狐浏览器，效果可能会更好</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>未使用其他第三方框架，首页和播放页均为纯原生的HTML，CSS， js实现（至于这个xframe-min-1.0.js文件可以参见我的GitHub xframe.js这个开源项目）</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影播放页面：此处也是类似于当前主流网站的的播放页面，左侧为播放窗口，右侧部分为电影的详细信息</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>底部导航：使用分栏的方式实现了底部的导航，前面的为友情链接，后面的一个为网站的微信，Q微博等联系方式</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>用户中心：这部分实现了修改密码，评论，登录，日志管理，收藏电影的功能，用户可以自由切换</li>\n</ol>\n</li>\n</ul>\n<h2>程序目录结构说明</h2>\n<pre class=\"prettyprint\"><code>vip.github.io:\n├─controllers               &#x2F;&#x2F; 控制层\n├─data                      &#x2F;&#x2F; 数据抓取层\n├─logs                      &#x2F;&#x2F; 后台日志\n│  ├─errlog                 &#x2F;&#x2F; 错误日志\n│  ├─othlog                 &#x2F;&#x2F; 其他日志\n│  └─reqlog                 &#x2F;&#x2F; 请求日志\n├─models                    &#x2F;&#x2F; 模型层\n├─static                    &#x2F;&#x2F; 静态页\n│  ├─css                    &#x2F;&#x2F; 样式表\n│  ├─images                 &#x2F;&#x2F; 静态图片资源\n│  └─js                     &#x2F;&#x2F; js脚本\n├─utils                     &#x2F;&#x2F; 工具相关\n├─views                     &#x2F;&#x2F; 视图层\n└─www                       &#x2F;&#x2F; 静态资源\n    ├─css                   &#x2F;&#x2F; 样式表\n    ├─html                  &#x2F;&#x2F; html文件\n    ├─images                &#x2F;&#x2F; 静态图片资源\n    ├─js                    &#x2F;&#x2F; js脚本\n    │  └─movielist          &#x2F;&#x2F; 搜索页电影列表\n    │      ├─components     &#x2F;&#x2F; top250&#x2F;即将上映\n    │      └─in_theaters    &#x2F;&#x2F; 正在热映\n    └─uploads               &#x2F;&#x2F; 文件上传目录\n        ├─avatar            &#x2F;&#x2F; 用户图像\n        └─movie             &#x2F;&#x2F; 电影图标\n\n</code></pre><h2>程序安装方法</h2>\n<ul>\n<li>\n<ol>\n<li>确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令：</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   git clone https:&#x2F;&#x2F;github.com&#x2F;xiugangzhang&#x2F;vip.github.io.git\n</code></pre><ul>\n<li>\n<ol>\n<li>进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   node app.js\n</code></pre><p>之后就会自动在浏览器中打开本程序安装的主界面；</p>\n<ul>\n<li>\n<ol>\n<li>如果是windows环境下，本程序提供了可视化的安装。用户可在程序的安装界面输入数据库名、数据库主机地址、数据库用户名、数据库密码，之后点击按钮立即安装即可，在输入的参数全部正确的情况下，就会后台自动安装程序，安装成功之后会自动跳转到网站首页；\n<img src=\"//static.cnodejs.org/FqNdjsfo5whahU-WvEC8WOpBBXA5\" alt=\"installing.jpg\"></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>如果是Linux环境下，请提前准备好数据库名（database=video）、数据库主机地址（host=localhost）、数据库用户名（user=root）、数据库密码（password=123456 ），按照如下格式保存为config.properties文件，请确保这里的配置信息和你的数据库配置信息完全一致；</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>    database=video               \n    host=localhost          \n    user=root               \n    password=123456         \n</code></pre><ul>\n<li>\n<ol>\n<li>在线演示站点：<a href=\"http://vip.52tech.tech\">http://vip.52tech.tech</a></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>对于安装和使用的过程中如果有什么问题和建议，也欢迎交流和提出建议，可以在issue去发起话题讨论，或直接联系邮箱：tech52admin@126.com</li>\n</ol>\n</li>\n</ul>\n</div>","title":"【VIP视频网站项目】基于Nodejs开发的VIP视频网站项目及源码分享【v1.0.3版】","last_reply_at":"2019-04-02T06:30:54.143Z","good":false,"top":false,"reply_count":24,"visit_count":15204,"create_at":"2018-09-30T12:19:59.585Z","author":{"loginname":"xiugangzhang","avatar_url":"https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"}},{"id":"5ca171d499e62a362ff41bd3","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>除了PM2之外,还有什么方法或者模块让node实现多进程。。。</p>\n</div>","title":"node多进程实现","last_reply_at":"2019-04-02T06:01:25.674Z","good":false,"top":false,"reply_count":10,"visit_count":474,"create_at":"2019-04-01T02:05:08.248Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5ca1e9dc31010b2dfbb41f35","author_id":"516cc5936d382773065b8e2f","tab":"share","content":"<div class=\"markdown-text\"><p>最近项目需要缓存一批二维码的点阵信息,\n最开始用二维数组存,发现太占资源,\n后来改用 Uint8Array 好了点,<br>\n想找个直接以bit为单元存储的类,结果没有;\n然后就有这个 <a href=\"https://github.com/cnwhy/BitMatrix\">BitMatrix</a>;</p>\n<p>用 ArrayBuffer来存储数据, 并把每个byte再拆成bit来用.   最终效果还是可以的, 有兴趣的可以关注一下, API还在完善中</p>\n<pre class=\"prettyprint\"><code>用 1 填充 2000 个 100*100 矩阵 内存占用情况:\n┌─────────┬──────────────────────┬────────────┬────────────┬────────────┐\n│ (index) │      className       │  heapUsed  │  external  │    sum     │\n├─────────┼──────────────────────┼────────────┼────────────┼────────────┤\n│    0    │     &#x27;BitMatrix&#x27;      │  &#x27;0.77MB&#x27;  │  &#x27;2.38MB&#x27;  │  &#x27;3.16MB&#x27;  │\n│    1    │     &#x27;Int8Matrix&#x27;     │  &#x27;0.87MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.94MB&#x27;  │\n│    2    │    &#x27;Uint8Matrix&#x27;     │  &#x27;0.81MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.89MB&#x27;  │\n│    3    │ &#x27;Uint8ClampedMatrix&#x27; │  &#x27;0.76MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.83MB&#x27;  │\n│    4    │    &#x27;Int16Matrix&#x27;     │  &#x27;0.68MB&#x27;  │ &#x27;38.15MB&#x27;  │ &#x27;38.83MB&#x27;  │\n│    5    │    &#x27;Uint16Matrix&#x27;    │  &#x27;0.68MB&#x27;  │ &#x27;38.15MB&#x27;  │ &#x27;38.83MB&#x27;  │\n│    6    │    &#x27;Int32Matrix&#x27;     │  &#x27;0.51MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.80MB&#x27;  │\n│    7    │    &#x27;Uint32Matrix&#x27;    │  &#x27;0.53MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.82MB&#x27;  │\n│    8    │   &#x27;Float32Matrix&#x27;    │  &#x27;0.53MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.82MB&#x27;  │\n│    9    │   &#x27;Float64Matrix&#x27;    │  &#x27;0.52MB&#x27;  │ &#x27;152.59MB&#x27; │ &#x27;153.11MB&#x27; │\n│   10    │     &#x27;AnyMatrix&#x27;      │ &#x27;153.23MB&#x27; │  &#x27;0.00MB&#x27;  │ &#x27;153.23MB&#x27; │\n│   11    │ &#x27;AnyMatrixUseObject&#x27; │ &#x27;159.15MB&#x27; │  &#x27;0.00MB&#x27;  │ &#x27;159.15MB&#x27; │\n└─────────┴──────────────────────┴────────────┴────────────┴────────────┘\n</code></pre></div>","title":"分享一个 Bit矩阵","last_reply_at":"2019-04-02T05:25:26.640Z","good":false,"top":false,"reply_count":2,"visit_count":220,"create_at":"2019-04-01T10:37:16.736Z","author":{"loginname":"cnwhy","avatar_url":"https://avatars1.githubusercontent.com/u/4178465?v=4&s=120"}},{"id":"5ca227df31010b2dfbb42023","author_id":"5933cd9e7e057cea7ceb98ab","tab":"ask","content":"<div class=\"markdown-text\"><p>下面是简单的示例：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; article\nconst ArticleSchema = new Schema({\n\ttitle: {\n        type: String,\n        required: true,\n    },\n    content: {\n        type: String,\n        required: true,\n    },\n    tags: [{\n        type: Schema.Types.ObjectId,\n        ref: &#x27;Tag&#x27;,\n    }],\n})\n\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; tag\nconst TagSchema = new Schema({\n    name: {\n        type: String,\n        default: &#x27;&#x27;,\n        required: true,\n    },\n    sort: {\n        type: Number,\n        default: 0,\n    },\n    articles: [{\n        type: Schema.Types.ObjectId,\n        ref: &#x27;Article&#x27;,\n    }],\n})\n</code></pre><p>我现在的做法是，添加文章时，更新tag下的articles字段，push 进去 article id。但我感觉这样是错的，因为如果修改了文章的标签，需要先删除原标签下的文章id，再添加到新标签下。求问有没有比较好的解决方式</p>\n</div>","title":"设计标签功能时，如何统计标签下文章数量？","last_reply_at":"2019-04-02T04:07:35.579Z","good":false,"top":false,"reply_count":5,"visit_count":229,"create_at":"2019-04-01T15:01:51.391Z","author":{"loginname":"wmui","avatar_url":"https://avatars0.githubusercontent.com/u/24876474?v=4&s=120"}},{"id":"5c74a05fab86b86ddf6b2ceb","author_id":"5928e4609e32cc84569a7431","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>一年前我花了个把月的时间仓促地写了个vue全家桶+koa+sokoet.io+mysql的应用来当做我的毕业设计—<a href=\"https://github.com/aermin/vue-chat\">vue-chat</a>，目前在github获得381个star，不过代码实现太糙了，推荐看<a href=\"https://github.com/aermin/react-chat\">新写的这个react版本的</a>哦。</p>\n<p>毕业后入职的公司用的是react技术栈，而且恰好是一个做通信应用相关的公司，所以萌生了下班业余时间用react技术栈重写一遍的想法。相比vue-chat,这个历时更长(大半年来利用空余时间不断重构迭代)，完成度挺高的，性能和代码质量相对更好（当然还有不少todo的优化空间），不再是只要求功能能跑就好了，而是不断的重构重写，也有了产品定位，而不是像vue-chat那样一味的模仿QQ和微信。</p>\n<h2>正文</h2>\n<h2>ghChat(react版)</h2>\n<p>之所以叫ghChat，是想着以后做一些GitHub的集成，希望让这个即时通讯工具成为chat tool for github.</p>\n<p>目前只支持github授权登录，和展示github用户公开的信息。</p>\n<h3>地址</h3>\n<p><a href=\"https://github.com/aermin/react-chat\">github项目地址</a>。<strong><em>本项目长期迭代，给个star支持一下</em></strong> 😄</p>\n<p><a href=\"https://im.aermin.top\">网站线上地址，支持直接github授权登录</a>。</p>\n<p>欢迎加入 “ghChat” 这个群交流呀，可搜索群名(不用全打)加入，也可点击机器人的邀请加入(如下图)</p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/53296199-6337a200-3845-11e9-8435-3f5480cca602.png\" alt=\"image\"></p>\n<h3>技术栈</h3>\n<p>前端React全家桶，后端node.js(koa2), 数据库MySQL, <a href=\"http://xn--SocKet-he0jn1y0ra0619b.io\">双向通信SocKet.io</a>, jwt鉴权等等。具体看package.json。有疑问的可以加ghChat群交流哦，我每天都在线，也可以私聊我，我的ghChat用户名是aermin(白色头像的那个)</p>\n<h3>目前进度</h3>\n<ul>\n<li>\n<p>账户</p>\n<ul>\n<li>[x] 登录</li>\n<li>[x] 注册</li>\n<li>[x] 退出登录</li>\n<li>[ ] 同时多设备登录</li>\n</ul>\n</li>\n<li>\n<p>对github的集成</p>\n<ul>\n<li>[x] 支持github授权登录</li>\n<li>[x] 展示github用户公开的信息</li>\n</ul>\n</li>\n<li>\n<p>UI</p>\n<ul>\n<li>[x] 弹窗，提示等基础组件</li>\n<li>[x] 响应式布局, 适配桌面端和移动端。以前vue-chat的实现只是移动端的布局。</li>\n</ul>\n</li>\n<li>\n<p>私聊</p>\n<ul>\n<li>[x] 私聊（外加重要的重构）：始化时请求聊天列表所有聊天对象的聊天记录（<s>后期限制为每个聊天项只初始化20条最新聊天内容</s>已实现，避免初始化数据量过大，时间过长），接着根据点击列表导致chatId(取自url params)的改变，重新渲染新的聊天内容。以前vue-chat的实现方式是点击进入每个聊天页面都会发1至多次请求然后渲染页面，性能较差</li>\n<li>[x] 添加联系人: 搜索到该用户并发送信息后即记录为好友(关系存DB)，会展示在双方的聊天列表</li>\n<li>[x] 好友资料展示</li>\n<li>[ ] 删除联系人</li>\n</ul>\n</li>\n<li>\n<p>群聊</p>\n<ul>\n<li>[x] 群聊 &amp;&amp; 重构： 本来是根据消息列表上的群和好友去遍历发HTTP请求拿数据，现在直接在后端整合好一次性用websocket发过来，减少请求次数且websocket在此情况性能更优一些； 完成群聊功能</li>\n<li>[x] 建群</li>\n<li>[x] 加群：搜索到该群并点击，会看到当前时间前的聊天记录，点加入按钮后即成功加入群(关系存DB)，开始受到群消息的广播，并且群会展示在聊天列表</li>\n<li>[x] 群资料展示</li>\n<li>[x] 退群：退群后聊天列表不再展示该群(DB中删除该关系)</li>\n<li>[x] 编辑群资料</li>\n</ul>\n</li>\n<li>\n<p>查询</p>\n<ul>\n<li>[x] 用户搜索&amp;&amp;群搜索： 支持前端模糊搜索和后端模糊搜索</li>\n</ul>\n</li>\n<li>\n<p>丰富聊天方式</p>\n<ul>\n<li>[x] 聊天页表： 实时按时间降序展示联系过的人和加入的群</li>\n<li>[x] 发图</li>\n<li>[x] 发表情</li>\n<li>[x] 发文件</li>\n<li>[x] 下载文件</li>\n<li>[x] Enter快捷键发送信息,发送按钮灰亮</li>\n<li>[x] @某人</li>\n<li>[x] 图片放大查看</li>\n<li>[x] 发送copy的图片(如qq截图后粘贴可直接发图)</li>\n<li>[ ] 提供在线表情库</li>\n<li>[ ] 支持Markdown</li>\n<li>[ ] 支持Quote</li>\n</ul>\n</li>\n<li>\n<p>新消息提示</p>\n<ul>\n<li>[x] 浏览器桌面通知（生产环境下，使用chrome的桌面通知需要你的网站是HTTPS的）</li>\n<li>[x] 列表未读消息数目提示</li>\n<li>[x] 刷新/重开/(不同账号)重登页面，列表未读消息的数目将仍然且准确显示</li>\n</ul>\n</li>\n<li>\n<p>不断的重构和性能优化</p>\n<ul>\n<li>[x] gzip 压缩</li>\n<li>[x] 聊天内容懒加载，每次获取20条数据</li>\n<li>[ ] sql优化</li>\n</ul>\n</li>\n<li>\n<p>其他</p>\n<ul>\n<li>[x] 机器人智能聊天回复</li>\n<li>[x] 部署SSL证书</li>\n<li>[x] 支持PWA</li>\n<li>[ ] 国际化</li>\n<li>[ ] 后端用TS重写，封装成sdk</li>\n<li>[ ] CI/CD</li>\n</ul>\n</li>\n</ul>\n<h3>项目展示：</h3>\n<p>github对gif图有限制，我就直接截图了，具体详情建议直接<a href=\"https://im.aermin.top\">线上体验</a>。</p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/53351929-e1d33300-395c-11e9-84a9-0a9fd793b5a1.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/53295822-b3f7cc80-383e-11e9-83b4-82a12bd4a24f.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/53296063-eb687800-3842-11e9-9da3-ab1c312c673d.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/53296160-afcead80-3844-11e9-9827-4b03303fcd3d.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/53351432-4346d200-395c-11e9-936e-e08d887f1355.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/54492992-42271600-4906-11e9-8828-a79e018af1c8.png\" alt=\"image\"></p>\n<p>Tips: 如何在chrome浏览器中开启对PWA的支持?</p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/54492876-3ab33d00-4905-11e9-8283-089f2af82399.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/24861316/54493160-9e3e6a00-4907-11e9-8f26-427c6753e2a4.png\" alt=\"image\"></p>\n<h3>项目结构图</h3>\n<pre class=\"prettyprint\"><code>├── LICENSE\n├── README-zh_CN.md\n├── README.md\n├── build\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── secret.js &#x2F;&#x2F; 放一些非公开的secret\n├── server  &#x2F;&#x2F; 后端代码\n│   ├── config.js\n│   ├── controllers\n│   ├── ecosystem.config.js\n│   ├── gulpfile.js\n│   ├── index.js\n│   ├── init  &#x2F;&#x2F; 初始化mysql\n│   ├── middlewares\n│   ├── models\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── routes  &#x2F;&#x2F; 后端路由，跟登录注册模块有关\n│   ├── socket  &#x2F;&#x2F; 除了登录注册，其他都用socket 来通信\n│   ├── utils\n│   └── yarn.lock\n├── src  &#x2F;&#x2F; 前端代码\n│   ├── App.js\n│   ├── app.scss\n│   ├── assets\n│   ├── components\n│   ├── containers\n│   ├── index.html\n│   ├── index.js\n│   ├── manifest.json\n│   ├── modules\n│   ├── redux\n│   ├── router\n│   ├── service-worker.js\n│   └── utils\n├── webpack.common.config.js  &#x2F;&#x2F; 通用webpack设置\n├── webpack.config.js  &#x2F;&#x2F;生产相关的webpack配置\n├── webpack.dev.config.js  &#x2F;&#x2F;开发相关的webpack配置\n</code></pre><h3>本地开发</h3>\n<ol>\n<li>项目拉到本地</li>\n</ol>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;aermin&#x2F;react-chat.git\n</code></pre><ol>\n<li>在react-chat文件夹下创建一个secret.js的空白文件。</li>\n</ol>\n<p>如果要使用github授权登录，使用七牛云cdn，生产环境数据库和jwt的secret的单独配置，就要填充相应的配置了。</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n  client_secret: &#x27;&#x27;, &#x2F;&#x2F; github授权登录需要的  github-&gt; settings -&gt;  Developer settings 那边生成获取\n  db: {\n    host: &#x27;&#x27;, &#x2F;&#x2F; 数据库IP\n    port: , &#x2F;&#x2F; 数据库端口\n    database: &#x27;&#x27;, &#x2F;&#x2F; 数据库名称\n    user: &#x27;&#x27;, &#x2F;&#x2F; 数据库用户名\n    password: &#x27;&#x27;, &#x2F;&#x2F; 数据库密码\n  },\n  secretValue: &#x27;&#x27;, &#x2F;&#x2F; json web token 的 secret\n  qiniu: { &#x2F;&#x2F; 七牛云配置\n    accessKey: &#x27;&#x27;,\n    secretKey: &#x27;&#x27;,\n    bucket: &#x27;&#x27;\n  }\n};\n</code></pre><ol>\n<li>下载前端的npm包</li>\n</ol>\n<pre class=\"prettyprint\"><code>cd react-chat\n</code></pre><pre class=\"prettyprint\"><code>npm i\n</code></pre><ol>\n<li>下载后端的npm包</li>\n</ol>\n<pre class=\"prettyprint\"><code>cd cd react-chat&#x2F;server \n</code></pre><pre class=\"prettyprint\"><code>npm i\n</code></pre><ol>\n<li>初始化数据库</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;需要先在本地建一个名为ghchat的mysql数据库\n配置如下看react-chat&#x2F;server&#x2F;config.js\n\nnpm run init_sql    &#x2F;&#x2F;然后查看下数据库是否init成功\n</code></pre><ol>\n<li>跑起前端和后端的代码</li>\n</ol>\n<pre class=\"prettyprint\"><code>npm run start\n</code></pre><pre class=\"prettyprint\"><code>cd ..      &#x2F;&#x2F; 返回到react-chat&#x2F;目录\n</code></pre><pre class=\"prettyprint\"><code>npm run start\n</code></pre><p>ps: 本地发图片和发文件和github登录无法使用，需要自己去github和七牛云申请一些东西</p>\n<h3>文档</h3>\n<p>这边开坑了一篇<a href=\"https://github.com/aermin/blog/issues/60\">ghChat开发历程</a> ，将不断地更新总结做这个全栈项目时会遇到的问题，知识点，和坑。</p>\n</div>","title":"独自写个高完成度的实时聊天应用，Node(Koa2)+React/Vue全家桶+Socket.io+MySQL+PWA","last_reply_at":"2019-04-02T01:42:19.776Z","good":false,"top":false,"reply_count":22,"visit_count":2558,"create_at":"2019-02-26T02:11:43.731Z","author":{"loginname":"aermin","avatar_url":"https://avatars1.githubusercontent.com/u/24861316?v=4&s=120"}},{"id":"5ca2088c31010b2dfbb41fc6","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d8bcbd33a48?w=3968&amp;h=2976&amp;f=jpeg&amp;s=4483019\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d8be0cca453?w=2976&amp;h=3968&amp;f=jpeg&amp;s=5742233\" alt=\"image\"></p>\n<p>3月31日去颐和园转了一圈, 拍的比较满意的几张照片</p>\n<h2>前言</h2>\n<p>本文主要参考了<a href=\"https://github.com/developit/preact\">preact的源码</a></p>\n<h2>准备工作</h2>\n<p>我们首先搭建开发的环境, 我们选择webpack4。值得注意的是, 因为我们需要解析JSX的语法, 我们需要使用**<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx**插件。</p>\n<p><a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx插件会将JSX语法做出以下格式的转换。<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx默认使用React.createElement, 我们可以通过设置插件的pragma配置项, 修改默认的函数名</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; before\nvar profile = &lt;div&gt;\n  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; &#x2F;&gt;\n  &lt;h3&gt;{[user.firstName, user.lastName].join(&#x27; &#x27;)}&lt;&#x2F;h3&gt;\n&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; after\nvar profile = React.createElement(&quot;div&quot;, null,\n  React.createElement(&quot;img&quot;, { src: &quot;avatar.png&quot;, className: &quot;profile&quot; }),\n  React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))\n);\n</code></pre><pre class=\"prettyprint language-js\"><code>\nconst webpack = require(&#x27;webpack&#x27;)\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)\nconst path = require(&#x27;path&#x27;)\nconst HappyPack = require(&#x27;happypack&#x27;)\n\nmodule.exports = {\n  devtool: &#x27;#cheap-module-eval-source-map&#x27;,\n\n  mode: &#x27;development&#x27;,\n\n  target: &#x27;web&#x27;,\n\n  entry: {\n    main: path.resolve(__dirname, &#x27;.&#x2F;example&#x2F;index.js&#x27;)\n  },\n\n  devServer: {\n    host: &#x27;0.0.0.0&#x27;,\n    port: 8080,\n    hot: true\n  },\n\n  resolve: {\n    extensions: [&#x27;.js&#x27;]\n  },\n\n  module: {\n    rules: [\n      {\n        test: &#x2F;\\.js$&#x2F;,\n        exclude: &#x2F;node_modules&#x2F;,\n        use: &#x27;happypack&#x2F;loader?id=js&#x27;\n      },\n      {\n        test: &#x2F;\\.css$&#x2F;,\n        use: [\n          {\n            loader: &#x27;style-loader&#x27;\n          },\n          {\n            loader: &#x27;css-loader&#x27;\n          }\n        ]\n      }\n    ]\n  },\n\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new HappyPack({\n      id: &#x27;js&#x27;,\n      threads: 4,\n      use: [\n        {\n          loader: &#x27;babel-loader&#x27;,\n          options: {\n            presets: [&#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;preset-env&#x27;],\n            plugins: [\n              &#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;plugin-syntax-dynamic-import&#x27;,\n              [\n                &quot;[@babel](&#x2F;user&#x2F;babel)&#x2F;plugin-transform-react-jsx&quot;,\n                {\n                  pragma: &#x27;h&#x27;\n                }\n              ]\n            ]\n          }\n        }\n      ]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, &#x27;.&#x2F;public&#x2F;index.html&#x27;)\n    })\n  ]\n}\n</code></pre><p>上面是完整的打包配置(如果严格来说, 类库应该单独打包的)。同时我们将<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx插件, pragma参数设置为&quot;h&quot;。我们在使用的时候, 只需要在文件中引入h函数即可。</p>\n<h2>创建VNode</h2>\n<p>我们在这里将会实现h方法, h方法的作用是创建一个VNode。根据编译结果可知, h函数的参数如下。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * type为VNode的类型\n * props为VNode的属性\n * childrens为VNode的子节点, 可能用多组子节点, 我们使用es6的rest参数\n *&#x2F;\nh(type, props, ...childrens)\n</code></pre><p>VNode本质就是Javascript中对象, 因此h函数只需要返回对应的对象即可。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createElement (type, props, ...children) {\n  if (!props) props = {}\n  \n  props.children = [...children]\n\n  let key = props.key\n\n\tif (key) {\n    delete props.key\n  }\n\n  return createVNode(type, props, null, key)\n}\n\nexport function createVNode (type, props, text, key) {\n  const VNode = {\n    type,\n    props,\n    text,\n    key,\n    _dom: null,\n    _children: null,\n    _component: null\n  }\n\n  return VNode\n}\n</code></pre><p>我们来使用一下，看一下h函数返回的结果, h函数返回的结果即是虚拟DOM</p>\n<pre class=\"prettyprint language-js\"><code>import { h } from &#x27;yy-react&#x27;\n\nconsole.log(\n  &lt;div&gt;\n    &lt;h1&gt;Hello&lt;&#x2F;h1&gt;\n    &lt;h1&gt;World&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n)\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d92d8d3ea36?w=1008&amp;h=618&amp;f=png&amp;s=103473\" alt=\"image\"></p>\n<h2>实现render</h2>\n<p>我们可以参考React的render函数的实现, render函数接受两个参数, React元素(VNode)以及container(挂载的DOM)。我们将要把VNode渲染成了真实的DOM节点。</p>\n<p>下面是render函数的实现, 我们在本期还没有来得及实现Diff方法, 读者可以不用关注于这些。</p>\n<p>整体代码的实现，参考(抄)了preact的源码的实现😏。(我还给preact的项目提交了pr😊，不过还没有merge😢)</p>\n<p>👇 <strong>文章的最后是具体实现, 但是一大坨对阅读不是很友好，不想看的可以略过，直接看解说。</strong></p>\n<p>我们首先将视角转向render, render函数里调用里diff函数, 将返回的dom挂载到document中。_prevVNode等属性我们会在以后用到，目前可以忽略。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function render (vnode, root) {\n  let oldVNode = root._prevVNode\n  let newVNode = root._prevVNode = vnode\n  let dom = oldVNode ? oldVNode._dom : null\n  let mounts = []\n  let newDom = diff(dom, root, newVNode, oldVNode, mounts)\n  if (newDom) {\n    root.appendChild(newDom)\n  }\n}\n</code></pre><p>在diff中，我们将对节点类型做出判断, VNode类型可以是普通的节点也可以是组件类型的节点, 我们这里先对普通类型的节点做出处理。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diff (\n  dom,\n  root,\n  newVNode,\n  oldVNode,\n  mounts,\n  force\n) {\n\n  let newType = newVNode.type\n\n  if (typeof newType === &#x27;function&#x27;) {\n    &#x2F;&#x2F; render component\n  } else {\n    dom = diffElementNodes(\n      dom,\n      newVNode,\n      oldVNode,\n      mounts\n    )\n  }\n\n  newVNode._dom = dom\n\n  return dom\n}\n</code></pre><p>我们接着将目光转向diffElementNodes函数, 在diffElementNodes函数中我们会根据具体节点类型创建对应的真实的DOM节点。\n例如文本类型的节点我们使用createTextNode, 而普通类型的我们使用createElement</p>\n<p>因为整个VNode呈现的一种树状结构, 面对树状结构免不了使用递归去遍历每一颗节点。我们这里将创建后dom，作为父节点传入diffChildren函数中(<strong>新创建的节点会append到这个父节点中</strong>)。递归的转换的每一个子节点以及子节点的子节点。</p>\n<p>由此我们也可知道，整个VNode树的渲染的顺序是由外向里的。但是设置VNode的props的顺序则是由里向外的。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffElementNodes (dom, newVNode, oldVNode, mounts) {\n\n  if (!dom) {\n    dom = newVNode.type === null ? document.createTextNode(newVNode.text) : document.createElement(newVNode.type)\n  }\n\n  newVNode._dom = dom\n\n  if (newVNode.type) {\n    if (newVNode !== oldVNode) {\n      let newProps = newVNode.props\n      let oldProps = oldVNode.props\n      if (!oldProps) {\n        oldProps = {}\n      }\n      diffChildren(dom, newVNode, oldVNode, mounts)\n      diffProps(dom, newProps, oldProps)\n    }\n  }\n\n  return dom\n}\n</code></pre><p>在diffChildren中, 我们将VNode的子VNode挂载到_children属性上, 遍历每一个子节点, 将子节点带入到diff中, 完成创建的过程</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffChildren (\n  root,\n  newParentVNode,\n  oldParentVNode,\n  mounts\n) {\n  let oldVNode, newVNode, newDom, i, j, index, p, oldChildrenLength\n\n  let newChildren = newParentVNode._children || \n                    toChildVNodeArray(newParentVNode.props.children, newParentVNode._children = [])\n\n  for (i = 0; i &lt; newChildren.length; i++) {\n    newVNode = newChildren[i]\n    oldVNode = index = null\n\n    newDom = diff(\n      oldVNode ? oldVNode._dom : null,\n      root,\n      newVNode,\n      oldVNode,\n      mounts,\n      null\n    )\n\n    if (newVNode &amp;&amp; newDom) {\n      root.appendChild(newDom)\n    }\n  }\n}\n</code></pre><p>我们在遍历递归完子节点后, 就可以使用diffProps来设置我们的root节点了。我们遍历newProps中的每一个key, 并使用setProperty将props设置到dom上, setProperty中对一些dom属性做了特殊的处理。比如处理了驼峰的css的key, 和数字的value自动添加px等。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n}\n\nfunction setProperty (dom, name, value, oldValue) {\n  if (name === &#x27;style&#x27;) {\n    let s = dom.style\n    if (typeof value === &#x27;string&#x27;) {\n\t\t\ts.cssText = value\n\t\t} else {\n\t\t\tif (typeof oldValue === &#x27;string&#x27;) {\n        s.cssText = &#x27;&#x27;\n      } else {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) {\n            s.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), &#x27;&#x27;)\n          }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), typeof v===&#x27;number&#x27; &amp;&amp; IS_NON_DIMENSIONAL.test(i)===false ? (v + &#x27;px&#x27;) : v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  } else if (value == null) {\n    dom.removeAttribute(name)\n  } else if (typeof value !== &#x27;function&#x27;) {\n    dom.setAttribute(name, value)\n  }\n}\n</code></pre><p>最后我们再次回到render函数，render函数最后的会将创建好的dom, append到挂载的dom中完成渲染。</p>\n<pre class=\"prettyprint language-js\"><code>\nroot.appendChild(newDom)\n</code></pre><h2>完整示例</h2>\n<blockquote>\n<p>github的仓库地址将在完成后放出</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; create-element.js\nexport function render (vnode, root) {\n  let oldVNode = root._prevVNode\n  let newVNode = root._prevVNode = vnode\n  let dom = oldVNode ? oldVNode._dom : null\n  let mounts = []\n  let newDom = diff(dom, root, newVNode, oldVNode, mounts)\n  if (newDom) {\n    root.appendChild(newDom)\n  }\n  runDidMount(mounts, vnode)\n}\n\n&#x2F;&#x2F; diff.js\nfunction diff (\n  dom,\n  root,\n  newVNode,\n  oldVNode,\n  mounts,\n  force\n) {\n  if (oldVNode == null || newVNode == null || newVNode.type !== oldVNode.type) {\n    if (!newVNode) return null\n    dom = null\n    oldVNode = {}\n  }\n\n  let newType = newVNode.type\n\n  if (typeof newType === &#x27;function&#x27;) {\n    &#x2F;&#x2F; render component\n  } else {\n    dom = diffElementNodes(\n      dom,\n      newVNode,\n      oldVNode,\n      mounts\n    )\n  }\n\n  newVNode._dom = dom\n\n  return dom\n}\n\nfunction diffElementNodes (dom, newVNode, oldVNode, mounts) {\n\n  if (!dom) {\n    dom = newVNode.type === null ? document.createTextNode(newVNode.text) : document.createElement(newVNode.type)\n  }\n\n  newVNode._dom = dom\n\n  if (newVNode.type) {\n    if (newVNode !== oldVNode) {\n      let newProps = newVNode.props\n      let oldProps = oldVNode.props\n      if (!oldProps) {\n        oldProps = {}\n      }\n      diffChildren(dom, newVNode, oldVNode, mounts)\n      diffProps(dom, newProps, oldProps)\n    }\n  }\n\n  return dom\n}\n\n&#x2F;&#x2F; diff-children.js\nfunction diffChildren (\n  root,\n  newParentVNode,\n  oldParentVNode,\n  mounts\n) {\n  let oldVNode, newVNode, newDom, i, j, index, p, oldChildrenLength\n\n  let newChildren = newParentVNode._children || \n                    toChildVNodeArray(newParentVNode.props.children, newParentVNode._children = [])\n\n  for (i = 0; i &lt; newChildren.length; i++) {\n    newVNode = newChildren[i]\n    oldVNode = index = null\n\n    newDom = diff(\n      oldVNode ? oldVNode._dom : null,\n      root,\n      newVNode,\n      oldVNode,\n      mounts,\n      null\n    )\n\n    if (newVNode &amp;&amp; newDom) {\n      root.appendChild(newDom)\n    }\n  }\n}\n\n&#x2F;&#x2F; diffProps.js\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n  for (let key in oldProps) {\n  }\n}\n\n&#x2F;&#x2F; diff-props\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n  for (let key in oldProps) {\n  }\n}\n\nfunction setProperty (dom, name, value, oldValue) {\n  if (name === &#x27;style&#x27;) {\n    let s = dom.style\n    if (typeof value === &#x27;string&#x27;) {\n\t\t\ts.cssText = value\n\t\t} else {\n\t\t\tif (typeof oldValue === &#x27;string&#x27;) {\n        s.cssText = &#x27;&#x27;\n      } else {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) {\n            s.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), &#x27;&#x27;)\n          }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), typeof v===&#x27;number&#x27; &amp;&amp; IS_NON_DIMENSIONAL.test(i)===false ? (v + &#x27;px&#x27;) : v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  } else if (value == null) {\n    dom.removeAttribute(name)\n  } else if (typeof value !== &#x27;function&#x27;) {\n    dom.setAttribute(name, value)\n  }\n}\n</code></pre><h3>其他</h3>\n<p><a href=\"https://juejin.im/post/5c97599fe51d450f357634fc\">preact源码分析(一)</a></p>\n<p><a href=\"https://juejin.im/post/5c9759cef265da611256430c\">preact源码分析(二)</a></p>\n<p><a href=\"https://juejin.im/post/5c975a1e6fb9a07107193af1\">preact源码分析(三)</a></p>\n<p><a href=\"https://juejin.im/post/5c9a36316fb9a070f03d083e\">preact源码分析(四)</a></p>\n<p><a href=\"https://juejin.im/post/5c9f7e126fb9a05e58493f9f\">preact源码分析(五)</a></p>\n</div>","title":"实现一个属于自己的React框架～～～～更新中～～～～～","last_reply_at":"2019-04-01T12:52:53.250Z","good":false,"top":false,"reply_count":1,"visit_count":228,"create_at":"2019-04-01T12:48:12.209Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5ca17f4399e62a362ff41c6d","author_id":"56cb313d66c88b5e490260a9","tab":"share","content":"<div class=\"markdown-text\"><p>我们是一个教练社区网站（<a href=\"http://bbs.zuqiuxunlian.com\">bbs.zuqiuxunlian.com</a>）,用的是cnodejs的开源代码搭建。\n由于现在手机浏览居多，小程序比较适合手机阅读。故而希望做一个客户端。\n可以参考已经有的很多开源的客户端。\n必须的功能：</p>\n<ol>\n<li>微信登录</li>\n<li>方便的留言框</li>\n<li>社区发帖</li>\n<li>自定义头像</li>\n</ol>\n<p>其他需求，可以讨论：</p>\n<ol>\n<li>简洁漂亮的界面</li>\n<li>设计优雅的分享</li>\n</ol>\n<p>有兴趣的报个价给我。\nvx：awong1900</p>\n</div>","title":"【外包】做一个社区的微信小程序客户端","last_reply_at":"2019-04-01T11:05:17.711Z","good":false,"top":false,"reply_count":6,"visit_count":503,"create_at":"2019-04-01T03:02:27.153Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5c9de1aa484eeb3634158513","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d66969005?w=640&amp;h=480&amp;f=jpeg&amp;s=104395\" alt=\"administration-articles-bank-261949.jpg\"></p>\n<p>2019年3月29日目前，Node 对 ES6 Module 的支持又有新进展。一个新的 PR 更新了当前 <code>--experimental-modules</code> 的实现方案。</p>\n<p><strong>type 动态判断模块加载模式</strong></p>\n<p>更新后的方案将根据 <code>package.json</code> 文件中指定的 type 值来判断 js 文件是使用 ESM 还是 commonjs</p>\n<ul>\n<li>如果 type 的值为 module 那么 js 文件将被作为 ESM 加载</li>\n<li>如果 type 的值为 commonjs 那么 js 文件将被作为 commonjs 来加载</li>\n</ul>\n<p>好处就是不需要使用 <code>.mjs</code> 这种与传统 js 扩展名不同的写法</p>\n<p><strong>使用 flag 指定入口文件模块加载模式</strong></p>\n<p>更新后的方案允许开发者使用 <code>--entry-type=type</code> 的方式来指定入口文件的解析方式，判断行为与 <code>package.json</code> 的 type 一致</p>\n<p><strong>支持新的扩展名 .cjs</strong></p>\n<p>新的扩展名 <code>.cjs</code> 表示在 module 模式的加载环境下去使用 commonjs 来加载扩展名为 <code>.cjs</code> 的模块</p>\n<p><strong>模块加载方式有所改变</strong></p>\n<p>新的 flag：<code>--es-module-specifier-resolution=[type]</code> 的默认值是 <code>explicit</code>，和可选值 <code>node</code>，在默认值的情况下引入模块时必须书写扩展名。</p>\n<blockquote>\n<p>This implies that ./x will only ever import exactly the sibling file “x” without appending paths or extensions. “x” is never resolved to x.mjs or x/index.mjs (or the .js equivalents).</p>\n<p>比方说这里加载 <code>./x</code> 模块，那么默认情况下只会加载名为 <code>x</code> 的模块，而不是去尝试加载 <code>x.mjs</code> 或 <code>x/index.mjs</code></p>\n<p>提案在此：<a href=\"https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal\">https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal</a></p>\n</blockquote>\n<p><strong>在 ESM 模式下加载 json 文件</strong></p>\n<p><code>--experimental-json-loader</code> flag 能够在 ESM 模式下加载 JSON 文件。</p>\n<p>导入的 json 文件将提供的 json 文件中的内容转化为一个对象或数组。就好像直接通过 JSON 模块 parse 了一样。</p>\n<p><strong>main 根据 type 的值确认入口文件加载模式</strong></p>\n<p>在 <code>package.json</code> 文件中的 main 字段指定入口文件，根据 type 字段来指定是 commonjs 还是 ESM 模式来加载。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/26745/commits/b1094dbe19f31f7a69ad16d193748f610b159073\">https://github.com/nodejs/node/pull/26745/commits/b1094dbe19f31f7a69ad16d193748f610b159073</a></li>\n<li><a href=\"https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal\">https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal</a></li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d668e008f?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt=\"JS 菌公众账号\"></p>\n<p>请关注我的订阅号，不定期推送有关 JS 的技术文章，只谈技术不谈八卦 😊</p>\n</div>","title":"Node 引入 ESM 新方案","last_reply_at":"2019-04-01T10:23:22.960Z","good":false,"top":false,"reply_count":2,"visit_count":604,"create_at":"2019-03-29T09:13:14.005Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5a311f729807389a1809f37a","author_id":"57b99bc2dcaeb5d932db220a","tab":"share","content":"<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能。目前项目处于刚开始阶段，欢迎对性能优化感兴趣的同学共同参与总结！</p>\n<p>Github: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F\">带宽与延迟</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li>TCP协议细节</li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">静态资源</a>\n<ul>\n<li>减少请求</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>Webpack</li>\n<li>CDN</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li>TLS原理</li>\n<li>性能影响</li>\n</ul>\n</li>\n<li>高性能JavaScript\n<ul>\n<li>V8与JIT</li>\n<li>内存泄露</li>\n<li>GC机制</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly</li>\n<li>PWA与离线应用</li>\n<li>即时运用与P2P</li>\n<li>Node.js性能优化</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>","title":"性能优化知识与实践整理","last_reply_at":"2019-04-01T09:47:23.208Z","good":false,"top":false,"reply_count":16,"visit_count":6677,"create_at":"2017-12-13T12:39:14.755Z","author":{"loginname":"laoqiren","avatar_url":"https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"}},{"id":"5ca1cdc231010b2dfbb41ded","author_id":"571053a36a2d2bda52de95ce","tab":"ask","content":"<div class=\"markdown-text\"><p>请求各位大佬，有个react问题，我在组件中写个了定时器同步系统时间，然后用鼠标滑动选择antd库下拉框时，每隔一秒，滑动条就会重新回到顶部，这如何解决？\n已经查明原因是 定时器每秒执行一次render导致的；但还不知道如何解决，菜鸟求助啊</p>\n</div>","title":"react 定时器 select下拉框出现问题","last_reply_at":"2019-04-01T08:37:22.812Z","good":false,"top":false,"reply_count":0,"visit_count":221,"create_at":"2019-04-01T08:37:22.812Z","author":{"loginname":"RocketV2","avatar_url":"https://avatars2.githubusercontent.com/u/12555991?v=4&s=120"}},{"id":"5bd11d0eb56c42645edb7c7b","author_id":"57d0da4c3cfda47b2c233155","tab":"ask","content":"<div class=\"markdown-text\"><p>egg项目使用egg-sequelize作为orm框架，该项目使用的mysql数据库和另外一个项目在一起，只是库不同而已，另外一个项目在做压力测试的时候将数据库cpu使用率提高到150%，持续时间挺长的。后来发现egg项目这边请求数据库老是超时，即使mysql数据库恢复正常之后，依然超时，重启egg项目之后才恢复正常，感觉就是连接池里的连接全部失效了而没有释放。想问问大家有没有遇到同样的问题，下面是错误信息和sequelize插件的配置：</p>\n<pre class=\"prettyprint\"><code>2018-10-25 09:01:22,923 ERROR 15972 Fatal error: ResourceRequest timed out, ctx: {&quot;request&quot;:{&quot;method&quot;:&quot;POST&quot;,&quot;url&quot;:&quot;&#x2F;dcc&#x2F;v1&#x2F;quota&#x2F;get&quot;,&quot;header&quot;:{&quot;host&quot;:&quot;dccs.bw-xt.com&quot;,&quot;x-real-ip&quot;:&quot;XXX&quot;,&quot;x-forwarded-for&quot;:&quot;XXX&quot;,&quot;connection&quot;:&quot;close&quot;,&quot;content-length&quot;:&quot;176&quot;,&quot;user-agent&quot;:&quot;Needs Clouds Client 5.0&quot;,&quot;accept&quot;:&quot;*&#x2F;*&quot;,&quot;content-type&quot;:&quot;application&#x2F;json;charset=utf-8&quot;}},&quot;response&quot;:{&quot;status&quot;:404,&quot;message&quot;:&quot;Not Found&quot;,&quot;header&quot;:{&quot;vary&quot;:&quot;Origin&quot;}},&quot;app&quot;:{&quot;env&quot;:&quot;prod&quot;,&quot;name&quot;:&quot;needs_dccs&quot;,&quot;baseDir&quot;:&quot;&#x2F;srv&#x2F;www&#x2F;vhosts&#x2F;Needs_Dccs&quot;,&quot;subdomainOffset&quot;:2,&quot;config&quot;:&quot;&lt;egg config&gt;&quot;,&quot;controller&quot;:&quot;&lt;egg controller&gt;&quot;,&quot;httpclient&quot;:&quot;&lt;egg httpclient&gt;&quot;,&quot;loggers&quot;:&quot;&lt;egg loggers&gt;&quot;,&quot;middlewares&quot;:&quot;&lt;egg middlewares&gt;&quot;,&quot;router&quot;:&quot;&lt;egg router&gt;&quot;,&quot;serviceClasses&quot;:&quot;&lt;egg serviceClasses&gt;&quot;},&quot;originalUrl&quot;:&quot;&#x2F;dcc&#x2F;v1&#x2F;quota&#x2F;get&quot;,&quot;req&quot;:&quot;&lt;original node req&gt;&quot;,&quot;res&quot;:&quot;&lt;original node res&gt;&quot;,&quot;socket&quot;:&quot;&lt;original node socket&gt;&quot;}\n2018-10-25 09:01:31,620 ERROR 15996 [-&#x2F;127.0.0.1&#x2F;-&#x2F;30005ms POST &#x2F;dcc&#x2F;v1&#x2F;quota&#x2F;get] nodejs.TimeoutError: ResourceRequest timed out\n    at ResourceRequest._fireTimeout (&#x2F;srv&#x2F;www&#x2F;vhosts&#x2F;Needs_Dccs&#x2F;node_modules&#x2F;generic-pool&#x2F;lib&#x2F;ResourceRequest.js:62:17)\n    at Timeout.bound (&#x2F;srv&#x2F;www&#x2F;vhosts&#x2F;Needs_Dccs&#x2F;node_modules&#x2F;generic-pool&#x2F;lib&#x2F;ResourceRequest.js:8:15)\n    at ontimeout (timers.js:427:11)\n    at tryOnTimeout (timers.js:289:5)\n    at listOnTimeout (timers.js:252:5)\n    at Timer.processTimers (timers.js:212:10)\nname: &quot;TimeoutError&quot;\n</code></pre><pre class=\"prettyprint\"><code>sequelize: {\n            dialect: &#x27;mysql&#x27;,\n            database: &#x27;database&#x27;,\n            username: &#x27;root&#x27;,\n            password: &#x27;password&#x27;,\n            timezone: &#x27;+08:00&#x27;,\n            host: &#x27;127.0.0.1&#x27;,\n            port: &#x27;3306&#x27;,\n            loggerLevel: &#x27;debug&#x27;,\n            dialectOptions: {\n                supportBigNumbers: true,\n                bigNumberStrings: true\n            },\n            define: {\n                freezeTableName: true,\n                charset: &#x27;utf8&#x27;,\n                dialectOptions: {\n                    collate: &#x27;utf8_general_ci&#x27;\n                },\n                timestamps: false\n            },\n            pool: {\n                max: 5,\n                min: 0,\n                acquire: 30000,\n                idle: 10000\n            }\n        },\n</code></pre></div>","title":"egg-sequelize连接池不能释放问题","last_reply_at":"2019-04-01T03:51:56.244Z","good":false,"top":false,"reply_count":2,"visit_count":1131,"create_at":"2018-10-25T01:31:58.696Z","author":{"loginname":"zhangmingfeng","avatar_url":"https://avatars1.githubusercontent.com/u/16733816?v=4&s=120"}}]}